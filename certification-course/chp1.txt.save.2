
<<------------------------------------------------------------------------------------------->>
                               Chapter 1

UEFI - Unified Extensible Firmware Interface
BIOS - Basic Input and Output System

- files in the /etc control startup behaviour especially those in the
  /etc/default and /etc/sysconfg

OBJECTIVES:
   -Explain the boot process
        The basic steps are:
           1. The BIOS/UEFI locates and executes the boot program, or boot loader.
           2. The boot loader loads the kernel.
           3. The kernel starts the 'init' process(pid=1).
           4. init manages system initialization, using conventional 'SysVinit' startup scripts, or
              using 'Upstart' or sysmd.
                                                         Checkmemory and hardware
                                                        /
           STEPS: BIOS ---> Power On Self Test(POST) --> 
                                                        \ 
                                                         Locates boot program in MBR(Master Boot Record)
                                                                                |
                                                                                V
									       GRUB(GRand Unified Bootloader)
											  |
							                                  V
                                                                                        Kernel
                                                                                          |
                                                                                        Hardware check
                                                                                          |
                                                                                        init processes start
                                                                                         /|\
                                                                                        / | \
                                                                               SysVinit   |  systemd
                                                                           init scripts   |               
                                                                                        Upstart

   -Identify several types of boot loaders.
        Types include: 
              GRUB
              LILO - Linux Loader (obsolete)
              efilinux - designed for the UEFI mechanism
              Das U-Boot - most popular loader for embedded Linux systems; others include
                           bareboot.
   -Describe what BIOS does.
        Checks memory and hardware, then locates Boot loader in MBR
   -Identify the relevant configuration files.
        they are: /etc/sysconfig for RHEL, and /etc/default for Debian systems
   -Describe how the system shuts down and reboots.
        commands examples: 
             sudo shutdown -h +1 "Power Failure imminent"
             sudo shutdown -h now
             sudo shutdown -r now
             sudo shutdown now
             FORMAT: shutdown [OPTIONS...] [TIME] [WALL...]
             find more help using 'shutdwon --help'

   Basic Steps For Computer Startup:
          1 - Boot loader
          2 - Linux kernel and initrd or initramfs loaded into memory and kernel executes
          3 - init process starts
          4 - Additional kernel modules(including device drivers) are loaded, system services started.


<<------------------------------------------------------------------------------------------------------------>>

                                    Chapter 3

 OBJECTIVES:
      - Explain what the role of the GRUB is.
          1 - handles the early phases of system startup
          2 - makes it possible to choose alternatives OS
          3 - makes it possible to choose alternative kernels and/or initial ramdisks at boot time
          4 - Boot paramters can be easily changed at boot time without having to edit configuration
              files, etc. in advance.
      - Understand the differences btween the GRUB 1 and GRUB 2 versions.
              GRUB 2 :
                 - file read at boot are
                      /boot/grub/grub.cfg or /boot/grub2/grub.cfg
                      This file is auto-generated by update-grub (or grub2-mkconfig on RHEL 7) 
                      based on configuration files in the /etc/grub.d directory and on /etc/default/grub
              GRUB 2 :
                 - file read at boot are
                      /boot/grub/grub.conf or /boot/grub/menu.lst.
                      In RHEL 5-7, it can be edited using the 'grubby utility'. Any changes made will be preserved
                      but in GRUB 2 any changes to grub.cfg is lost when next it is auto-generated.
      - Be familiar with the interactive selections you can make at boot.
              - on entering the GRUB environment after BIOS setup menu appears
              - menu offers the ffl.: 
                          ~ list of bootable images
                          ~ interactive shell - for altering the available stanzas
                          ~ enter pure shell command
                          ~ reinstall GRUB
                
      - Know how to install GRUB                                                    GRUB 1 using a program called grub -> $ sudo grub or grub-install
                                                                                   /                                      > root (hd0, 0)
              - install grub program and associated utilities in proper locations -                                       > setup (hd0)
                                                                                   \                                      > exit
                                                                                    \
                                                                                     GRUB 2 uses a bunch of utilities like grub2-* or grub-*
                                                                                        -> $ sudo grub2-install /dev/sda
                                                                                                            
              - installing files GRUB needs to operate at boot time, either under /boot/grub or /boot/grub2
                           : Linux kernel files vmlinux-*, initramfs-* which need to be in the /boot directory
              - installing GRUB as the boot loader in the system
          
      - Explain how the configuration files that GRUB needs are used and modified.
                    - the two locations that are used in the reconstruction of the /boot/grub2/grub.cfg are:                  
                          /etc/default/grub, and
                          /etc/grub.d
        
-----------------------------------------------------------------------------------------------------------------<<
                   GRUB Device Nomenclature

     - sda1 is (hd0,1) in GRUB 2 but (hd0,0) in GRUB 1
     - sdc4 -s (hd2,4) in GRUB 2 but (hd1,3) in GRUB 1

  Note: In the configuration file, each stanza has to specify what the root partition is i.e. the partition that contains
        the 'kernel' itself(in the /boot directory), say /boot had its own directory /dev/sda1, then
        For GRUB 1, 
                title 3.17.3
                       root (hd0,0)
                       kernel vmlinuz-3.17.3 ro root=/dev/sda2 quiet
                       intrd intramfs-3.17.1.img
    
        If /boot is not in its own partition, it might look like
                  title 3.17.3
                        root (hd0,0)
                        kernel /boot/vmlinuz-3.17.3 ro root=/dev/sda1 quiet
                        intrd /boot/intramfs-3.17.3.img

       it is also fine to do kernel (hd0,0)/vmlinuz

<<------------------------------------------------------------------------------------------------------------------------>>

                                      Chapter 4 init: SystemV, Upstart, Systemd

Steps: 
	Device recognition and initialization
	launch system services
	filesystems made available
	start important management systems
	make system available
	

OBJECTIVE:
	- Understand the importance of the 'init' process.
	- Explain the traditional SysVinit method works and how it incorporates 'runlevels' and
	  what happens in each one.
	- know how to use chkconfig and service to start and stop services or make them persistent across
	  reboots.
	- Understand the alternative 'Upstart' and 'systemd'
	- Use 'systemctl' to configure and control 'systemd'.
	
	
The mother process controller is the /sbin/init or simple called 'init'

                                 System Runlevels
     -----------------------------------------------------------------------------
       Runlevel         |         Meaning                                        
     -----------------------------------------------------------------------------
           S,s          |  Same as 1
           0            |  Shutdown system and turn off
           1            |  Single User Mode
           2            |  Multiple user, no NFS, only text login
           3            |  Mutiple user, with NFS and network, only text login
           4            |  Not used
           5            |  Multiple user, with NFS and network, graphical login with X
           6            |  Reboot
     ------------------------------------------------------------------------------
     
     
telinit can be used to change from one level to another
$ sudo /sbin/telinit 5

On start the 'init' process reads the /etc/inittab
	- Here the scripts to be run are mentioned along with other parameters.
	- Format: id:runlevel(s):action:process
		- where:
		    id - a unique 1-4 character identification for the entry
		    runlevel(s) - zero or more single characters or digit indicating runlevel the action will be taken for.
		    action - describes the action to be taken.
		    process - specifies the process to be executed.
		    
		    
The 'init' run steps:
                                                         1                    2
	(init)/sbin/init -----> /etc/inittab ===> (script)rc.sysinit ===> (script)rc
	                   |                            ^                        ^                                           
	                   |				|                        |
	                   |			[start LVM, mount fs, etc.]      |
	                   |							 |
	    <Reads from for scripts to be run>                                   |
	    									 |
	    					<makes system to go to rc.d/rc[0-6].d and run all scrips there>


Note: All runlevel directory link back to the /etc/init.d directory where all the scripts actually reside.
      Start scripts start with S in name
      Kill scripts start with K in name
      --Controlling which initialization scripts are run on entry to each runlevel involves managing the symbolic links,
        this can be done manually but the 'chkconfig' utility is used to do this efficiently.
Note: Ubuntu uses update-rc.d inplace of chkconfig

	chkconfig useage:
		- check service to see if it is set to run in the current level
		'chkconfig service_name'
		
		- see what services are configured to run in each of the run levels
		'chkconfig --list [service names]
		
		- Turn on a certain service next time the system boots
		'sudo chconfig somme_service on'
		
		- Do not turn on a service next time the system boots
		'chkconfig some_service off
		
		- Change a currently running service
		'sudo chkconfig service_name [stop | start]
		
The chkconfig utility process explained:
  Syntax in scripts:
     #  chkconfig: 2345 10 90		
		--meaning runlevel 2, 3, 4, 5
		--start script -> S10
		--stop script -> K90
		
		
UPSTART:
	 is 'event driven', rather than being a set of serial procedures. Event notifications are sent to the 'init' process to tell it to execute
	certain commands at the right time after pre-requisites have been fulfilled. 'Upstart' is being superseded by 'systemd'.

	Upstart configuration files are:
		- /etc/init/rcS.conf
		- /etc/rc-sysinit.conf
		- /etc/inittab
		- /etc/init/rc.conf
		- /etc/rc[0-6].d
		
	Upstart events are found in the /etc/event.d or (in Ubuntu) /etc/apm/event.d
	
	Using 'initctl'	you can view, start, stop jobs in much the same way as that 'service' does.
	       syntax: initctl options command
	               - options includes: start, stop, restart, reload, status, list, emit
	               
	      More info: www.//upstart.ubuntu.com/cookbook

UPSTART STEPS:
--------------


             (/sbin/init)
                |
Kernel -----> init
                  \
                   \
                    \
                    V
                    rcS.conf(script)
                    |
                    |
                    |
                    V
                    rc-sysinit.conf(script)
                   /
                  /
                 V
   -LVM loaded
   -Mount filesystems
   -Execute all runlevel
    scripts specified in the 
    /etc/inittab via
    the rc.conf script
   -then prefdm.conf is run
    at runlevel 5 
		
SYSTEMD(systemd)
---------------
  features include:
      - compatible with SysVinit scripts.
      - Boosts faster.
      - provides paralization capabilities.
      - Uses socket and D-Bus activation for starting services.
      - Replaces scripts with programs.
      - Offers on-demand starting daemons
      - Keeps track of processes using cgroups(control groups).
      - snapshots capabilities and system state restoration.
      - can be a drop in replacement for SysVinit.
      - uses '.service' files rather than bash scripts
  Examples of new configuration files for systemd are:
      - /etc/hostname (redhat, replaces /etc/sysconfig/network)
      - /etc/HOSTNAME SUSE
      - /etc/hostname Debian
      - /etc/vconsole.conf - default keyboard mapping and console font
      - /etc/sysctl.d/*.conf - drop-in directory for kernel 'sysctl' parameters
      - /etc/os-release - distros ID
      
      
     Runlevel    Target Units                          Description
     0           runlevel0.target, poweroff.target     Shut down and power off the system.
     1           runlevel1.target, rescue.target       Set up a rescue shell.
     2           runlevel2.target, multi-user.target   Set up a non-graphical multi-user system.
     3           runlevel3.target, multi-user.target   Set up a non-graphical multi-user system.
     4           runlevel4.target, multi-user.target   Set up a non-graphical multi-user system.
     5           runlevel5.target, graphical.target    Set up a graphical multi-user system.
     6           runlevel6.target, reboot.target       Shut down and reboot the system.

NOTE:--------------------------------------------------------------
      SysVinit                                       systemd
         |                                              |
         v                                              v
   service utility                               systemctl utility
   update-rc.d, invoke-rc.d -- Ubuntu, Debian
   sysv-rc-conf -- Ubuntu                           
   chkconfig -- RHEL, CentOS, Fedora     
   ----------------------------------------------------------------
   
 'systemctl' is the main utility for managing services in 'systemd'
 
  Basic syntax: $ systemctl [options] command [name]
  
  
  Useage examples:
        $ systemctl --> shows status of systemd controlled services
        
        $ systemctl list-units -t service --all --> show all available services
        
        $ systemctl list-units -t service  --> show only active services
        
        $ sudo systemctl start foo --> start or activate foo  service
          sudo systemctl start foo.service
          sudo systemctl start /path/to/foo.service
        
        $ sudo systemctl stop foo.service --> stop(deactivate) a service
        
        $ sudo systemctl enable sshd.service --> to enable or disable a service
          sudo systemctl disable sshd.service 
              -- equivalent to chkconfig --add/ --del and doesn't actually start the service.
        
       
        
<---------------------------------------------------------------------------------------------------------------->
                                               Chp 5 Linux Filesystem Tree Layout
                                               
Types of file system differ by:
	- purpose
	- size
	- ownership
	- sharing
	
Objectives of chpter 5:
	- Explain why Linux requires the organization of one big filesystem tree, and 
	  what the major considerations are for how it is done.
	- Know the role played by the Filesystem Hierarcchy Standard.
	- Describe what must be available at boot in the root(/) directory, and waht
	  can available only once the system has started.
	- Explain each of the main subdirectory trees in terms of purpose and contents.

File systems are:
1. Shareable vs. non-shareable
2. Variable vs static


File main directories present in FHS

Directory       In FHS?         Purpose
/		Yes		Primary directory of the entire file system hierarchy.
/bin		Yes		Essential executable programs that must be available in 'single user mode'.
/boot		Yes		Files neede to boot - kernel, initrd ot initramfs, images, boot configuration files and bootloader programs.
/dev		Yes		Device nodes, used to interact with hardware devices.
/etc		Yes		System wide configuration files.
/home		Yes		User home directoies including personal settings, files, etc.
/lib		Yes		Libraries required bt executable binaries in .bin and /sbin.
/lib64		No		64-bit libraries requires by executable binaries in /binand /sbin, for systems which can run both 32-bit and 64-bit programs.
/media		Yes		Mount points for removable media such as CDs, DVDs, USB sticks etc.
/mnt		Yes		Temporarily mounted filesystems.
/opt		Yes		Optional application software packages.
/proc		Yes 		Virtual pseudo-filesystem giving information about the system and processes running on it
				Can be used to alter system parameters.
/sys		No		Virtual psuedo-filesystem giving information about the system and processes running on it. Can be used to
				alter system parameters. Similar to a device tree and is part of the Unified Device Model.				
/root		Yes		Home directory of the root user.
/sbin		Yes		Essential system binaries.
/srv		Yes		Site-specific data served up by the system. Seldom used.
/tmp		Yes		Temporary files; on many distributions lost across reboot and may be a ramdisk in memory.
/usr		Yes		Multi-user applications, utilities and data; theoretically read-only.
/var		Yes		Variable data that changes during system operation.


 The three file associated with each 'bootable kernel' are:
 	- vmlinuz -- compressed Linux kernel
 	- initramfs or initrd -- Initial RAM Filesystem, mounted before the real root filesystem becomes available.
 	- config --configuration file used when compiling the kernel. Used mainly for bookkeeping and reference
 	- System.map -- The kernel 'symbol table', useful for debudding. Gives the 'hexadecimal addresses' of all kernel symbols.
 	
---------------------
/bin
---------------------
	contains executable binaries needed buy both admin and unprivileged users.
	may not contain cubdirectories

---------------------
/boot
---------------------
	two main absolutely essential files are: vmlinuz --> comporessed kernels
						 initramfs --> initial RAM Filesystem
	 	
---------------------
/dev
---------------------
	contains special device files(also known as device nodes) this represent devices built into or connected to the system.
	network devices do not have device nodes in Linux and are referenced by names such as eth1 or wlan0
	
---------------------
/etc
---------------------
	contains machine-local configuration files; there should be no executable binary programs.
	sample files and directories include:
		- /etc/sysconfig -- system configuration and directories (Red Hat)
		- /etc/default -- same as above (Debian)
		- /etc/skel -- contains skeleton files used to populate newly created home directories
		- /etc/init.d -- contains start up amd shut down scripts when using System V initialization
		
--------------------
/home
--------------------
	contains all personal configuration, data, and executable programs.
	
	
-------------------
/lib
-------------------
	contains only thise libraries needed to execute the binaries in /bin and /sbin. These are useful for booting the system
	and executing commands within the filesystem.
	kernel modules(device and filesystem drivers) are located under /lib/modules/<kernel-version-number>
	PAM(Pluggable Authentication Modules) files are stored in the /lib/security
	Systems that support both 32-bit and 64-bit libraries use /lib and /lib64 respectively.
	
-------------------
/media
-------------------
	used to mount filesystems on removeable media such as CDs, DVDs, and USB drives or even old floppy disks
	on SUSE and RHEL 7 removable media will pop up under /run/media/[username]/....
	
------------------
/mnt
------------------
	used to temporarily mount a filesystem when needed. Like 
		- NFS
		- Samba
		- CIFS
		- AFS
		
-----------------
/opt
-----------------
	used by software packages that wish to keep all their files in one isolated place rather than scatter themall over
	the system.
	Example: dolphy_app -- /opt/dolphy_app/bin, /opt/dolphy_app/man
	Special subdirectories of /opt are:
		/opt/bin
	
----------------
/proc
----------------
	mount point for a pseudo-filesystem, where information only resides in memory, not on disk. Like /dev the /proc is
	 empty on a non-running system.
	Here each active process on the system has its own subdirectory that gives detailed information about the state of the process,
	 the resources it is using, and its history.
	Important pseudo-files include: 
		- /proc/interrupts -------
		- /porc/meminfo          |
		- /proc/mounts           |-------> system's hardware
		- /proc/partitionso ------
		
		- /proc/filesystem ------|
		- /proc/sys/-------------|-------> system configuration information and interfaces
		
----------------
/sys
----------------
	mount point for sysfs pseudo-filesystem, where infromation resides only in memory
	sysfs is used both to gather information about the system, and modify its behaviour while running.
	
	
---------------
/root
---------------
	home directory of the root user
	
--------------
/sbin
--------------
	contains binaries essential for booting, restoring, recovering, and/or repairing	
	must be able to mount other filesystems on /usr, /home and other locations
	these programs should be included here:
		- fdisk, fsck, getty, halt, ifconfig, init, mkfs, mkswap, reboot, route, swapon, swapoff, update.
	contains binaries essential for booting, restoring, recovering, and/or repairing in addition to those binaries in /bin.
	they must also be able to mount other filesystems on '/usr, /home' and other locations, once the root system is known to be in good health during boot.
	The following programs shld be included in this directory, if their subsystems are installed:
		fdisk, fsck, getty, halt, ifconfig, init, mkfs, mkswap, reboot, route, swapon, swapoff, update.
	Note: some recent repos are merging /sbin and /usr/sbin as well as /bin and /usr/bin.
		
-------------
/tmp
-------------
	store temporary files, accessed by any user
	reset /tmp behaviour on RHEL 6 using 'systemctl mask tmp.mount
	for temporary files
	regularly cleaned of its contents at regurlar basis using 'cron jobs' or 'at reboot'
	files here are stored in memory not disk
	Note: canceling the usage of /tmp for creating large files can be done using the command: systemctl mask tmp.mount, then 'reboot'
	
-------------
/usr
-------------
	secondary hierarchy
	used for files that are not needed for system booting.
	may be located at location different from root directory
	software packages should not create subdirectories directly under /usr
	typically read-only data
	contains binaries which are not need in single user mode
	
	
	Directory       |          Purpose
	---------------------------------------------------------------------------------
	/usr/bin	| binaries for applications not needed in single user mode
	/usr/include	| header files for compiling applications
	/usr/lib	| Libraries for programs in /bin and /sbin.
	/usr/lib64	| 64-bit libraries for 64-bit programs in /bin and /sbin.
	/usr/sbin	| Non-essential system binaries, e.g. system daemons.
	/usr/share	| Shared dara used by applications, architecture-independent
	/usr/src	| Source files usually for linux kernel.
	/usr/X11R6	| X Window files; generally obsolete.
	/usr/local	| Local data and programs specific to the host. Subdirectories include bin, sbin, lib, share, include, etc.
	

-----------------
/var
----------------
	contains variable (or volatile) data files that change frequently during system operation.
	Examples:
		- Log file
		- Spool directories and files for printing, mail queues, etc.
		- Admin data files
		- Transient and temporary files
		
		
		Directory       |         Purpose
		--------------------------------------------------------------------------------
		/var/ftp	| ftp server base
		/var/lib	| Persistent data modified by programs as they run.
		/var/lock	| Lock files used to control simultaneous access to resources.
		/var/log	| Log files
		/var/mail	| User mailboxes
		/var/run	| Information about the running system since the last boot.
		/var/spool	| Tasks spooled or waiting to be processed, such as print queues.
		/var/tmp	| Temporary files to be persisted across reboot, at times linked to /tmp
		/var/www	| Root for website hierarchies.
		
		
-----------------
/run
-----------------
	stores transient files: those that contain run-time information, which may need to be written early in system startup.



<------------------------------------------------------------------------------------------------------>

				Chapter 6
This lies at the heart of the Linux operating system.
It controls access to hardware, competition for resources between different applications and other tasks, handles I/O activity and 
	files and data storage, security, networking, etc.
Adding kernel command line parameters at boot time, the system can be made to behave in many different ways.

	Learning Objectives:
		- grasp the main responsibilities the kernel must fulfill and how it achieves them.
		- Explain what parameters can be set on the kernel command line and how to make them effective either for just one
		  system boot, or persistently.
		- know where to find detailed documentation on these parameters.
		- know how to use sysctl to set kernel parameters either after the system starts, or persistently across system reboots.
        

	kernel serves as a connection between hardware and software
	handles all connected devices using 'device drivers'
	
	Main kernel:
	        - system initialization and  boot up.
	        - process scheduling
	        - memory management
	        - controlling access to hardware
	        - I/O between applications and storage devices.
	        - Implementation of local and network filesystems.
	        - Security control, both locally (such as filesystem permissions) and over the network.
	        - networking control.

Kernel Command Line:
        GRUB version 1
                /boot/grub/grub.conf
        GRUB version 2
                /boot/grub2/grub.cfg
                
        cat /proc/cmdline -- shows what cmdline a system was booted with.
	        

-Kernel Boot Parameters:
	sources of documentation for kernel parameters includes:-
		- in the kernel source Documentation/kernel-parameters.txt
		- Online, at http://kernel.org/doc/Documentation/kernel-parameters.txt
		- On the as kernel-doc or linux-doc
		- By typing 'man dootparam'
		
	parameters may be typed as an argument or in the form param=value, where value can be a 'string, integer, array of integers
	etc.
	
	Bootparameters:
		- ro -- mounts root device read-only on boot.
		- root -- root filesystem
		- rd_LVM_LV -- it activates the root filesystem in the logical volume specified
		- rd_NO_LUKS -- disables crypto LUKS detection.
		- rd_NO_DM -- disables DM RAID detection.
		- LANG -- is the system language.
		- SYSFONT -- is the console font.
		- KEYTABLE -- is the keytable filename.
		- rhgb -- for graphical boot support on Red Hat systems.
		- quiet -- disables most log messages.
		
	'sysctl' interface can be used to read and tune kernel parameters at run time. To display current values - 'sysctl -a'
		- More details: sysctl use -- man 8 sysctl
				sysctl() use -- man 2 sysctl
		- if settings are in /etc/sysctl.conf -- man sysctl.conf 
	Note: 
		kernel command line allows specification of start up options
		sysctl allows specification of run time options
		
		
<------------------------------------------------------------------------------------------>
                
                Chapter 7 Kernel Modules
                
Objectives:
	- list the advantages of utilizing kernel modules.
	- use insmod, rmmod, and modprobe to load and unload kernel modules.
	- know how to use modinfo to find out information about kernel modules.
	
	
	Advatages of kernel modules include:
		- it facilitates development
		- kernel reboots are nor required
		- 
		
		
	Module utilities:
		- lsmod -- list modules
		- insmod -- directly load modules
		- rmmod -- directly remove modules
		- modprobe -- load or unload modules, using a pre-built module database with dependency information
		- depmod -- rebuild the module dependency database; needed by modprobe and modinfo
		- modinfo -- display information about a module.
	Syntax for load and unloading modules
		sudo /sbin/rmmod module_name
		sudo /sbin/insmod <pathto>/module_name 
		           
		------------OR using modprobe---------
		
		sudo /sbin/modprobe module_name
		sudo /sbin/modprobe -r module_name
		
	information on modules can be gotten using:
		modinfo module_name OR /sbin/modinfo my_module, /sbin/modinfo <pathto>/my_module.ko
		 
		A modules status can be seen in the /sys pseudo-filesystem directory tree
			- e.g.:
				for module e1000
				/sys/module/e1000
				some or if not all parameters can be 'read or written' under /sys/module/e1000/parameters
	Module parameters:loading module with parameters
		sudo /sbin/insmod <pathto>/e1000.ko debug=2 copybreak=256
		sudo /sbin/modprobe e1000 debug=2 copybreak=256
		Note: files in the /etc/modprobe.d control some parameters that come into play when using modprobe

<---------------------------------------------------------------------------------------------------------->
			                  
			                  Chapter 8. Devices and UDEV
	
	Linux uses udev to discovering devices (hardware and peripheral) both during boot and later on when connected to the system.
	Device nodes are created automatically and then used by apps and OS subsystems to communicate with and transfer data to and from devices.
	
	Objectives:
		- Explain the role of 'device nodes and how they use major and minor numbers.
		- Understand the need for the udev method and list its key components.
		- Descibe how the udev device manager functions.
		- Identify udev rule files and learn how to create custom rules.
	Character and block devices have filesystem entries associated with them; network devices in Linux do not.
		These device nodes can be used by programs to communicate with devices, using I/O system calls such as 'open(), close(), read(),
		and write().
	Network devices work by transmitting and recieving packets of data.
	
	Device nodes can be created with:
		sudo mknod [-m mode] /dev/name <type> <major> <minor>
		e.g., mknode -m 666 /dev/mycdrv c 254 1
		
					Device Nodes
					------------
					
	---------------------------------------------------------------------------------
        |		              Application                                       |
	---------------------------------------------------------------------------------
		                                  / \			/ \
		                                   |                     |
		                                   |                     |
		                                   | 	                 |
		                                   V       		 |
	-------------------------------------------------------------    |
	|          Virtual File System                             |    |
	-------------------------------------------------------------    |
		     / \                / \           / \                |
		      |			 |	       |                 |
		      |			 |	       |                 |
		      V			 V	       |                 |
	-------------------     --------------         |  -----------    |
        |character node   |     |block node  |<--------|  |socket   |    |        
        -------------------     -------------             ----------     |
               / \                  / \                       / \        |
                |	             |                         |         |
                |                    |                         |         |
                V                    V                         V         V
        -------------------     --------------           -----------------
        |character driver |     |file system |           | TCP/IP        |
        |                 |     |            |           |Appletalk, etc |
        -------------------     --------------           -----------------
                / \                 / \                       / \
                 |                   |                         |
                 |                   |                         |
                 |                   V                         V
                 |             --------------            -----------------
                 |             |block driver|            |network driver |
                 |             --------------            -----------------
                 |                  / \                       / \
                 |                   |                         |
                 |	             |                         |
                 V                   V                         V
        ---------------------------------------------------------------------------------
        |                              Hardware                                         |
        ---------------------------------------------------------------------------------
