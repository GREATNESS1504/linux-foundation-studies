
<<------------------------------------------------------------------------------------------->>
                               Chapter 1

UEFI - Unified Extensible Firmware Interface
BIOS - Basic Input and Output System

- files in the /etc control startup behaviour especially those in the
  /etc/default and /etc/sysconfg

OBJECTIVES:
   -Explain the boot process
        The basic steps are:
           1. The BIOS/UEFI locates and executes the boot program, or boot loader.
           2. The boot loader loads the kernel.
           3. The kernel starts the 'init' process(pid=1).
           4. init manages system initialization, using conventional 'SysVinit' startup scripts, or
              using 'Upstart' or sysmd.
                                                         Checkmemory and hardware
                                                        /
           STEPS: BIOS ---> Power On Self Test(POST) -->
                                                        \
                                                         Locates boot program in MBR(Master Boot Record)
                                                                                |
                                                                                V
									       GRUB(GRand Unified Bootloader)
											  |
							                                  V
                                                                                        Kernel
                                                                                          |
                                                                                        Hardware check
                                                                                          |
                                                                                        init processes start
                                                                                         /|\
                                                                                        / | \
                                                                               SysVinit   |  systemd
                                                                           init scripts   |
                                                                                        Upstart

   -Identify several types of boot loaders.
        Types include:
              GRUB
              LILO - Linux Loader (obsolete)
              efilinux - designed for the UEFI mechanism
              Das U-Boot - most popular loader for embedded Linux systems; others include
                           bareboot.
   -Describe what BIOS does.
        Checks memory and hardware, then locates Boot loader in MBR
   -Identify the relevant configuration files.
        they are: /etc/sysconfig for RHEL, and /etc/default for Debian systems
   -Describe how the system shuts down and reboots.
        commands examples:
             sudo shutdown -h +1 "Power Failure imminent"
             sudo shutdown -h now
             sudo shutdown -r now
             sudo shutdown now
             FORMAT: shutdown [OPTIONS...] [TIME] [WALL...]
             find more help using 'shutdwon --help'

   Basic Steps For Computer Startup:
          1 - Boot loader
          2 - Linux kernel and initrd or initramfs loaded into memory and kernel executes
          3 - init process starts
          4 - Additional kernel modules(including device drivers) are loaded, system services started.


<<------------------------------------------------------------------------------------------------------------>>

                                    Chapter 3

 OBJECTIVES:
      - Explain what the role of the GRUB is.
          1 - handles the early phases of system startup
          2 - makes it possible to choose alternatives OS
          3 - makes it possible to choose alternative kernels and/or initial ramdisks at boot time
          4 - Boot paramters can be easily changed at boot time without having to edit configuration
              files, etc. in advance.
      - Understand the differences btween the GRUB 1 and GRUB 2 versions.
              GRUB 1 :
                 - file read at boot are
                      /boot/grub/grub.cfg or /boot/grub2/grub.cfg
                      This file is auto-generated by update-grub (or grub2-mkconfig on RHEL 7)
                      based on configuration files in the /etc/grub.d directory and on /etc/default/grub
              GRUB 2 :
                 - file read at boot are
                      /boot/grub/grub.conf or /boot/grub/menu.lst.
                      In RHEL 5-7, it can be edited using the 'grubby utility'. Any changes made will be preserved
                      but in GRUB 2 any changes to grub.cfg is lost when next it is auto-generated.
      - Be familiar with the interactive selections you can make at boot.
              - on entering the GRUB environment after BIOS setup menu appears
              - menu offers the ffl.:
                          ~ list of bootable images
                          ~ interactive shell - for altering the available stanzas
                          ~ enter pure shell command
                          ~ reinstall GRUB

      - Know how to install GRUB                                                    GRUB 1 using a program called grub -> $ sudo grub or grub-install
                                                                                   /                                      > root (hd0, 0)
              - install grub program and associated utilities in proper locations -                                       > setup (hd0)
                                                                                   \                                      > exit
                                                                                    \
                                                                                     GRUB 2 uses a bunch of utilities like grub2-* or grub-*
                                                                                        -> $ sudo grub2-install /dev/sda

              - installing files GRUB needs to operate at boot time, either under /boot/grub or /boot/grub2
                           : Linux kernel files vmlinux-*, initramfs-* which need to be in the /boot directory
              - installing GRUB as the boot loader in the system

      - Explain how the configuration files that GRUB needs are used and modified.
                    - the two locations that are used in the reconstruction of the /boot/grub2/grub.cfg are:
                          /etc/default/grub, and
                          /etc/grub.d

-----------------------------------------------------------------------------------------------------------------<<
                   GRUB Device Nomenclature

     - sda1 is (hd0,1) in GRUB 2 but (hd0,0) in GRUB 1
     - sdc4 -s (hd2,4) in GRUB 2 but (hd1,3) in GRUB 1

  Note: In the configuration file, each stanza has to specify what the root partition is i.e. the partition that contains
        the 'kernel' itself(in the /boot directory), say /boot had its own directory /dev/sda1, then
        For GRUB 1,
                title 3.17.3
                       root (hd0,0)
                       kernel vmlinuz-3.17.3 ro root=/dev/sda2 quiet
                       intrd intramfs-3.17.1.img

        If /boot is not in its own partition, it might look like
                  title 3.17.3
                        root (hd0,0)
                        kernel /boot/vmlinuz-3.17.3 ro root=/dev/sda1 quiet
                        intrd /boot/intramfs-3.17.3.img

       it is also fine to do kernel (hd0,0)/vmlinuz

<<------------------------------------------------------------------------------------------------------------------------>>

                                      Chapter 4 init: SystemV, Upstart, Systemd

Steps:
	Device recognition and initialization
	launch system services
	filesystems made available
	start important management systems
	make system available


OBJECTIVE:
	- Understand the importance of the 'init' process.
	- Explain the traditional SysVinit method works and how it incorporates 'runlevels' and
	  what happens in each one.
	- know how to use chkconfig and service to start and stop services or make them persistent across
	  reboots.
	- Understand the alternative 'Upstart' and 'systemd'
	- Use 'systemctl' to configure and control 'systemd'.


The mother process controller is the /sbin/init or simple called 'init'

                                 System Runlevels
     -----------------------------------------------------------------------------
       Runlevel         |         Meaning
     -----------------------------------------------------------------------------
           S,s          |  Same as 1
           0            |  Shutdown system and turn off
           1            |  Single User Mode
           2            |  Multiple user, no NFS, only text login
           3            |  Mutiple user, with NFS and network, only text login
           4            |  Not used
           5            |  Multiple user, with NFS and network, graphical login with X
           6            |  Reboot
     ------------------------------------------------------------------------------


telinit can be used to change from one level to another
$ sudo /sbin/telinit 5

On start the 'init' process reads the /etc/inittab
	- Here the scripts to be run are mentioned along with other parameters.
	- Format: id:runlevel(s):action:process
		- where:
		    id - a unique 1-4 character identification for the entry
		    runlevel(s) - zero or more single characters or digit indicating runlevel the action will be taken for.
		    action - describes the action to be taken.
		    process - specifies the process to be executed.


The 'init' run steps:
                                                         1                    2
	(init)/sbin/init -----> /etc/inittab ===> (script)rc.sysinit ===> (script)rc
	                   |                            ^                        ^
	                   |							|                        |
	                   |					[start LVM, mount fs, etc.]      |
	                   |							 |
	    <Reads from for scripts to be run>                                   |
	    									 |
	    					<makes system to go to rc.d/rc[0-6].d and run all scrips there>


Note: All runlevel directory link back to the /etc/init.d directory where all the scripts actually reside.
      Start scripts start with S in name
      Kill scripts start with K in name
      --Controlling which initialization scripts are run on entry to each runlevel involves managing the symbolic links,
        this can be done manually but the 'chkconfig' utility is used to do this efficiently.
Note: Ubuntu uses update-rc.d inplace of chkconfig

	chkconfig useage:
		- check service to see if it is set to run in the current level
		'chkconfig service_name'

		- see what services are configured to run in each of the run levels
		'chkconfig --list [service names]

		- Turn on a certain service next time the system boots
		'sudo chconfig somme_service on'

		- Do not turn on a service next time the system boots
		'chkconfig some_service off

		- Change a currently running service
		'sudo chkconfig service_name [stop | start]

The chkconfig utility process explained:
  Syntax in scripts:
     #  chkconfig: 2345 10 90
		--meaning runlevel 2, 3, 4, 5
		--start script -> S10
		--stop script -> K90


UPSTART:
	 is 'event driven', rather than being a set of serial procedures. Event notifications are sent to the 'init' process to tell it to execute
	certain commands at the right time after pre-requisites have been fulfilled. 'Upstart' is being superseded by 'systemd'.

	Upstart configuration files are:
		- /etc/init/rcS.conf
		- /etc/rc-sysinit.conf
		- /etc/inittab
		- /etc/init/rc.conf
		- /etc/rc[0-6].d

	Upstart events are found in the /etc/event.d or (in Ubuntu) /etc/apm/event.d

	Using 'initctl'	you can view, start, stop jobs in much the same way as that 'service' does.
	       syntax: initctl options command
	               - options includes: start, stop, restart, reload, status, list, emit

	      More info: www.//upstart.ubuntu.com/cookbook

UPSTART STEPS:
--------------


             (/sbin/init)
                |
Kernel -----> init
                  \
                   \
                    \
                    V
                    rcS.conf(script)
                    |
                    |
                    |
                    V
                    rc-sysinit.conf(script)
                   /
                  /
                 V
   -LVM loaded
   -Mount filesystems
   -Execute all runlevel
    scripts specified in the
    /etc/inittab via
    the rc.conf script
   -then prefdm.conf is run
    at runlevel 5

SYSTEMD(systemd)
---------------
  features include:
      - compatible with SysVinit scripts.
      - Boosts faster.
      - provides paralization capabilities.
      - Uses socket and D-Bus activation for starting services.
      - Replaces scripts with programs.
      - Offers on-demand starting daemons
      - Keeps track of processes using cgroups(control groups).
      - snapshots capabilities and system state restoration.
      - can be a drop in replacement for SysVinit.
      - uses '.service' files rather than bash scripts
  Examples of new configuration files for systemd are:
      - /etc/hostname (redhat, replaces /etc/sysconfig/network)
      - /etc/HOSTNAME SUSE
      - /etc/hostname Debian
      - /etc/vconsole.conf - default keyboard mapping and console font
      - /etc/sysctl.d/*.conf - drop-in directory for kernel 'sysctl' parameters
      - /etc/os-release - distros ID


     Runlevel    Target Units                          Description
     0           runlevel0.target, poweroff.target     Shut down and power off the system.
     1           runlevel1.target, rescue.target       Set up a rescue shell.
     2           runlevel2.target, multi-user.target   Set up a non-graphical multi-user system.
     3           runlevel3.target, multi-user.target   Set up a non-graphical multi-user system.
     4           runlevel4.target, multi-user.target   Set up a non-graphical multi-user system.
     5           runlevel5.target, graphical.target    Set up a graphical multi-user system.
     6           runlevel6.target, reboot.target       Shut down and reboot the system.

NOTE:--------------------------------------------------------------
      SysVinit                                       systemd
         |                                              |
         v                                              v
   service utility                               systemctl utility
   update-rc.d, invoke-rc.d -- Ubuntu, Debian
   sysv-rc-conf -- Ubuntu
   chkconfig -- RHEL, CentOS, Fedora
   ----------------------------------------------------------------

 'systemctl' is the main utility for managing services in 'systemd'

  Basic syntax: $ systemctl [options] command [name]


  Useage examples:
        $ systemctl --> shows status of systemd controlled services

        $ systemctl list-units -t service --all --> show all available services

        $ systemctl list-units -t service  --> show only active services

        $ sudo systemctl start foo --> start or activate foo  service
          sudo systemctl start foo.service
          sudo systemctl start /path/to/foo.service

        $ sudo systemctl stop foo.service --> stop(deactivate) a service

        $ sudo systemctl enable sshd.service --> to enable or disable a service
          sudo systemctl disable sshd.service
              -- equivalent to chkconfig --add/ --del and doesn't actually start the service.



<---------------------------------------------------------------------------------------------------------------->
                                               Chp 5 Linux Filesystem Tree Layout

Types of file system differ by:
	- purpose
	- size
	- ownership
	- sharing

Objectives of chpter 5:
	- Explain why Linux requires the organization of one big filesystem tree, and
	  what the major considerations are for how it is done.
	- Know the role played by the Filesystem Hierarcchy Standard.
	- Describe what must be available at boot in the root(/) directory, and waht
	  can available only once the system has started.
	- Explain each of the main subdirectory trees in terms of purpose and contents.

File systems are:
1. Shareable vs. non-shareable
2. Variable vs static


File main directories present in FHS

Directory       In FHS?         Purpose
/		Yes		Primary directory of the entire file system hierarchy.
/bin		Yes		Essential executable programs that must be available in 'single user mode'.
/boot		Yes		Files neede to boot - kernel, initrd ot initramfs, images, boot configuration files and bootloader programs.
/dev		Yes		Device nodes, used to interact with hardware devices.
/etc		Yes		System wide configuration files.
/home		Yes		User home directories including personal settings, files, etc.
/lib		Yes		Libraries required bt executable binaries in .bin and /sbin.
/lib64		No		64-bit libraries requires by executable binaries in /binand /sbin, for systems which can run both 32-bit and 64-bit programs.
/media		Yes		Mount points for removable media such as CDs, DVDs, USB sticks etc.
/mnt		Yes		Temporarily mounted filesystems.
/opt		Yes		Optional application software packages.
/proc		Yes 		Virtual pseudo-filesystem giving information about the system and processes running on it
				Can be used to alter system parameters.
/sys		No		Virtual psuedo-filesystem giving information about the system and processes running on it. Can be used to
				alter system parameters. Similar to a device tree and is part of the Unified Device Model.
/root		Yes		Home directory of the root user.
/sbin		Yes		Essential system binaries.
/srv		Yes		Site-specific data served up by the system. Seldom used.
/tmp		Yes		Temporary files; on many distributions lost across reboot and may be a ramdisk in memory.
/usr		Yes		Multi-user applications, utilities and data; theoretically read-only.
/var		Yes		Variable data that changes during system operation.


 The three file associated with each 'bootable kernel' are:
 	- vmlinuz -- compressed Linux kernel
 	- initramfs or initrd -- Initial RAM Filesystem, mounted before the real root filesystem becomes available.
 	- config --configuration file used when compiling the kernel. Used mainly for bookkeeping and reference
 	- System.map -- The kernel 'symbol table', useful for debugging. Gives the 'hexadecimal addresses' of all kernel symbols.

---------------------
/bin
---------------------
	contains executable binaries needed buy both admin and unprivileged users.
	may not contain subdirectories

---------------------
/boot
---------------------
	two main absolutely essential files are: vmlinuz --> comporessed kernels
						 initramfs --> initial RAM Filesystem

---------------------
/dev
---------------------
	contains special device files(also known as device nodes) this represent devices built into or connected to the system.
	network devices do not have device nodes in Linux and are referenced by names such as eth1 or wlan0

---------------------
/etc
---------------------
	contains machine-local configuration files; there should be no executable binary programs.
	sample files and directories include:
		- /etc/sysconfig -- system configuration and directories (Red Hat)
		- /etc/default -- same as above (Debian)
		- /etc/skel -- contains skeleton files used to populate newly created home directories
		- /etc/init.d -- contains start up amd shut down scripts when using System V initialization

--------------------
/home
--------------------
	contains all personal configuration, data, and executable programs.


-------------------
/lib
-------------------
	contains only thise libraries needed to execute the binaries in /bin and /sbin. These are useful for booting the system
	and executing commands within the filesystem.
	kernel modules(device and filesystem drivers) are located under /lib/modules/<kernel-version-number>
	PAM(Pluggable Authentication Modules) files are stored in the /lib/security
	Systems that support both 32-bit and 64-bit libraries use /lib and /lib64 respectively.

-------------------
/media
-------------------
	used to mount filesystems on removeable media such as CDs, DVDs, and USB drives or even old floppy disks
	on SUSE and RHEL 7 removable media will pop up under /run/media/[username]/....

------------------
/mnt
------------------
	used to temporarily mount a filesystem when needed. Like
		- NFS
		- Samba
		- CIFS
		- AFS

-----------------
/opt
-----------------
	used by software packages that wish to keep all their files in one isolated place rather than scatter themall over
	the system.
	Example: dolphy_app -- /opt/dolphy_app/bin, /opt/dolphy_app/man
	Special subdirectories of /opt are:
		/opt/bin

----------------
/proc
----------------
	mount point for a pseudo-filesystem, where information only resides in memory, not on disk. Like /dev the /proc is
	 empty on a non-running system.
	Here each active process on the system has its own subdirectory that gives detailed information about the state of the process,
	 the resources it is using, and its history.
	Important pseudo-files include:
		- /proc/interrupts -------
		- /porc/meminfo          |
		- /proc/mounts           |-------> system's hardware
		- /proc/partitions  ------

		- /proc/filesystem ------|
		- /proc/sys/-------------|-------> system configuration information and interfaces

----------------
/sys
----------------
	mount point for sysfs pseudo-filesystem, where information resides only in memory
	sysfs is used both to gather information about the system, and modify its behaviour while running.


---------------
/root
---------------
	home directory of the root user

--------------
/sbin
--------------
	contains binaries essential for booting, restoring, recovering, and/or repairing
	must be able to mount other filesystems on /usr, /home and other locations
	these programs should be included here:
		- fdisk, fsck, getty, halt, ifconfig, init, mkfs, mkswap, reboot, route, swapon, swapoff, update.
	contains binaries essential for booting, restoring, recovering, and/or repairing in addition to those binaries in /bin.
	they must also be able to mount other filesystems on '/usr, /home' and other locations, once the root system is known to be in good health during boot.
	The following programs shld be included in this directory, if their subsystems are installed:
		fdisk, fsck, getty, halt, ifconfig, init, mkfs, mkswap, reboot, route, swapon, swapoff, update.
	Note: some recent repos are merging /sbin and /usr/sbin as well as /bin and /usr/bin.

-------------
/tmp
-------------
	store temporary files, accessed by any user
	reset /tmp behaviour on RHEL 6 using 'systemctl mask tmp.mount
	for temporary files
	regularly cleaned of its contents at regurlar basis using 'cron jobs' or 'at reboot'
	files here are stored in memory not disk
	Note: canceling the usage of /tmp for creating large files can be done using the command: systemctl mask tmp.mount, then 'reboot'

-------------
/usr
-------------
	secondary hierarchy
	used for files that are not needed for system booting.
	may be located at location different from root directory
	software packages should not create subdirectories directly under /usr
	typically read-only data
	contains binaries which are not need in single user mode


	Directory       |          Purpose
	---------------------------------------------------------------------------------
	/usr/bin	| binaries for applications not needed in single user mode
	/usr/include	| header files for compiling applications
	/usr/lib	| Libraries for programs in /bin and /sbin.
	/usr/lib64	| 64-bit libraries for 64-bit programs in /bin and /sbin.
	/usr/sbin	| Non-essential system binaries, e.g. system daemons.
	/usr/share	| Shared dara used by applications, architecture-independent
	/usr/src	| Source files usually for linux kernel.
	/usr/X11R6	| X Window files; generally obsolete.
	/usr/local	| Local data and programs specific to the host. Subdirectories include bin, sbin, lib, share, include, etc.


-----------------
/var
----------------
	contains variable (or volatile) data files that change frequently during system operation.
	Examples:
		- Log file
		- Spool directories and files for printing, mail queues, etc.
		- Admin data files
		- Transient and temporary files


		Directory       |         Purpose
		--------------------------------------------------------------------------------
		/var/ftp	| ftp server base
		/var/lib	| Persistent data modified by programs as they run.
		/var/lock	| Lock files used to control simultaneous access to resources.
		/var/log	| Log files
		/var/mail	| User mailboxes
		/var/run	| Information about the running system since the last boot.
		/var/spool	| Tasks spooled or waiting to be processed, such as print queues.
		/var/tmp	| Temporary files to be persisted across reboot, at times linked to /tmp
		/var/www	| Root for website hierarchies.


-----------------
/run
-----------------
	stores transient files: those that contain run-time information, which may need to be written early in system startup.



<------------------------------------------------------------------------------------------------------>

				Chapter 6
This lies at the heart of the Linux operating system.
It controls access to hardware, competition for resources between different applications and other tasks, handles I/O activity and
	files and data storage, security, networking, etc.
Adding kernel command line parameters at boot time, the system can be made to behave in many different ways.

	Learning Objectives:
		- grasp the main responsibilities the kernel must fulfill and how it achieves them.
		- Explain what parameters can be set on the kernel command line and how to make them effective either for just one
		  system boot, or persistently.
		- know where to find detailed documentation on these parameters.
		- know how to use sysctl to set kernel parameters either after the system starts, or persistently across system reboots.


	kernel serves as a connection between hardware and software
	handles all connected devices using 'device drivers'

	Main kernel:
	        - system initialization and  boot up.
	        - process scheduling
	        - memory management
	        - controlling access to hardware
	        - I/O between applications and storage devices.
	        - Implementation of local and network filesystems.
	        - Security control, both locally (such as filesystem permissions) and over the network.
	        - networking control.

Kernel Command Line:
        GRUB version 1
                /boot/grub/grub.conf
        GRUB version 2
                /boot/grub2/grub.cfg

        cat /proc/cmdline -- shows what cmdline a system was booted with.


-Kernel Boot Parameters:
	sources of documentation for kernel parameters includes:-
		- in the kernel source Documentation/kernel-parameters.txt
		- Online, at http://kernel.org/doc/Documentation/kernel-parameters.txt
		- On the as kernel-doc or linux-doc
		- By typing 'man bootparam'

	parameters may be typed as an argument or in the form param=value, where value can be a 'string, integer, array of integers
	etc.

	Bootparameters:
		- ro -- mounts root device read-only on boot.
		- root -- root filesystem
		- rd_LVM_LV -- it activates the root filesystem in the logical volume specified
		- rd_NO_LUKS -- disables crypto LUKS detection.
		- rd_NO_DM -- disables DM RAID detection.
		- LANG -- is the system language.
		- SYSFONT -- is the console font.
		- KEYTABLE -- is the keytable filename.
		- rhgb -- for graphical boot support on Red Hat systems.
		- quiet -- disables most log messages.

	'sysctl' interface can be used to read and tune kernel parameters at run time. To display current values - 'sysctl -a'
		- More details: sysctl use -- man 8 sysctl
				sysctl() use -- man 2 sysctl
		- if settings are in /etc/sysctl.conf -- man sysctl.conf
	Note:
		kernel command line allows specification of start up options
		sysctl allows specification of run time options


<------------------------------------------------------------------------------------------>

                Chapter 7 Kernel Modules

Objectives:
	- list the advantages of utilizing kernel modules.
	- use insmod, rmmod, and modprobe to load and unload kernel modules.
	- know how to use modinfo to find out information about kernel modules.


	Advatages of kernel modules include:
		- it facilitates development
		- kernel reboots are not required
		-


	Module utilities:
		- lsmod -- list modules
		- insmod -- directly load modules
		- rmmod -- directly remove modules
		- modprobe -- load or unload modules, using a pre-built module database with dependency information
		- depmod -- rebuild the module dependency database; needed by modprobe and modinfo
		- modinfo -- display information about a module.
	Syntax for loading and unloading modules
		sudo /sbin/rmmod module_name
		sudo /sbin/insmod <pathto>/module_name

		------------OR using modprobe---------

		sudo /sbin/modprobe module_name
		sudo /sbin/modprobe -r module_name

	information on modules can be gotten using:
		modinfo module_name OR /sbin/modinfo my_module, /sbin/modinfo <pathto>/my_module.ko

		A modules status can be seen in the /sys pseudo-filesystem directory tree
			- e.g.:
				for module e1000
				/sys/module/e1000
				some or if not all parameters can be 'read or written' under /sys/module/e1000/parameters
	Module parameters:loading module with parameters
		sudo /sbin/insmod <pathto>/e1000.ko debug=2 copybreak=256
		sudo /sbin/modprobe e1000 debug=2 copybreak=256
		Note: files in the /etc/modprobe.d control some parameters that come into play when using modprobe

<---------------------------------------------------------------------------------------------------------->

			                  Chapter 8. Devices and UDEV

	Linux uses udev to discover devices (hardware and peripheral) both during boot and later on when connected to the system.
	Device nodes are created automatically and then used by apps and OS subsystems to communicate with and transfer data to and from devices.

	Objectives:
		- Explain the role of 'device nodes and how they use major and minor numbers.
		- Understand the need for the udev method and list its key components.
		- Descibe how the udev device manager functions.
		- Identify udev rule files and learn how to create custom rules.

	Character and block devices have filesystem entries associated with them; network devices in Linux do not.
		These device nodes can be used by programs to communicate with devices, using I/O system calls such as 'open(), close(), read(),
		and write().
	Network devices work by transmitting and recieving packets of data.

	Device nodes can be created with:
		sudo mknod [-m mode] /dev/name <type> <major> <minor>
		e.g., mknod -m 666 /dev/mycdrv c 254 1

					Device Nodes
					------------

	---------------------------------------------------------------------------------
        |		              Application                                       |
	---------------------------------------------------------------------------------
		                                  / \			/ \
		                                   |                     |
		                                   |                     |
		                                   | 	                 |
		                                   V       		 |
	-------------------------------------------------------------    |
	|                        Virtual File System                |    |
	-------------------------------------------------------------    |
		     / \                / \           / \                |
		      |			 |	       |                 |
		      |			 |	       |                 |
		      V			 V	       |                 |
	-------------------     --------------         |  -----------    |
        |character node   |     |block node  |<--------|  |socket   |    |
        -------------------     -------------             ----------     |
               / \                  / \                       / \        |
                |	             |                         |         |
                |                    |                         |         |
                V                    V                         V         V
        -------------------     --------------           -----------------
        |character driver |     |file system |           | TCP/IP        |
        |                 |     |            |           |Appletalk, etc |
        -------------------     --------------           -----------------
                / \                 / \                       / \
                 |                   |                         |
                 |                   |                         |
                 |                   V                         V
                 |             --------------            -----------------
                 |             |block driver|            |network driver |
                 |             --------------            -----------------
                 |                  / \                       / \
                 |                   |                         |
                 |	             |                         |
                 V                   V                         V
        ---------------------------------------------------------------------------------
        |                              Hardware                                         |
        ---------------------------------------------------------------------------------


	The 'major' and 'minor' numbers identify the driver associated with the device.
	In most cases (but not all) device nodes of the same type (block or character) with the same major number use the same driver.
	Minor numbers are used only by the device driver to differentiate between the different devices it may control.
	mknod() and stat() : return information about 'major' and 'minor' numbers.

	udev:
	-----
	POSIX -- PORTABLE OPERATING SYSTEM INTERFACE
	udev -- user device
	Handles the dynamical generation of device nodes. It replaced devfs and hotplug
	udev Components:
		udev runs a daemon(udevd or systemd-udevd) and monitors a netlink socket.
		mechanism: device --ADDED--> uevent kernel facility --SENDS MESSAGE--> socket --> udev [addes or removes nodes]
		 - libudev -: library which allows access to information about the devices
		 - udevd -: daemon that manages the /dev directory.
		 - udevadm -: utility for control and diagnostics.
	udev main configuration file: /etc/udev/udev.conf
	udev naming rules file: /etc/udev/rules.d
	udev Device Manager:-
		mechanism --: udev[receives message from kernel] --PARSES--> Rule-Setting Files[ in /etc/udev/rules.d/*.rules]
			Actions taken includes:-
				- device node naming
				- device node and symbolic links creation.
				- setting file permissions and ownership for the device node.
				- taking other actions to initialize and make device available.
				These rules are completely customizable
	udev rules are located under:
		/etc/udev/rules.d/<rulename>.rules, e.g. 30-usb.rules, 90-mycustom.rules



							Create device node in /dev
								    / \
								     |
								     |
								     |
						                   udevd
						                   /  \
						                  /    \
						                 /      \
						                /        \
						               /          \
	                                                      /		   \
						       kernel module    Rules database

	Creating udev Rules
		format: <match><op>value [, ...] <assignment><op>value [, ...]

<------------------------------------------------------------------------------------------------------>
					Chapter 9. Partitioning and Formatting Disks

	Schemes are selected based on the following:
		- size of system
		- number of users and their needs
		- type of hardware available
		- type of data bus to which the storage is attached

	Objectives:

		- Describe and contrast the most common types of hard disks and data buses.
		- Explain disk geometry and other partitioning concepts.
		- Understand how disk devices are named and how to identify their associated device nodes.
		- Distinguish among and select different partitioning stratigies.
		- Use utilities such as blkid and fdisk.
		- Back up and restore partition tables

	Common Disk Types:
		- IDE and EIDE(Integrated Drive Electronics, and Enhanced IDE)
			obsolete
		- SATA(Serial Advanced Technology Attachment)
			seen as SCSI devices by the OS
			smaller cable size( 7 pins) when compared to PATA, a.k.a. IDE
			native hot swapping, and faster
			more efficiant data transfer
			can handle 16GB/s, but 3 GB/s and 6 GB/s are more common
		- SCSI(Small Computer Systems Interface)
			lower capacity than SATA
			faster than SATA
			work better in parallel, as when used in RAID configurations
			versions may include:- Fast, Wide, Ultra, and UltraWide
			more varied device drivers unlike SATA
			disk range vary from 8 bit bus to 16 bit bus
			transfer rate of 5 MB/s(narrow, standard SCSI) to about 160 MB/s (Ultra-Wide SCSI-3)
			Single ended device controllers [host up to 7 devices, max cable length 6 meters]
			Differential controllers[host up to 15 devices, max length 12 meters]
		- SAS(Serial Attached SCSI)
			newer point to point serial protocol replacing the earlier Parallel SCSI interface
			data transfer rate similar to SATA
			better performance
		- USB(Universal Serial Bus)
			include pen drives and extensible USB drives
			OS sees them as SCSI devices
			in the same category as SSDs drives
	Disk Geometry:
		- parameters include:-
			heads, cylinders, tracks and sectors
		- Structure:-



		                                                    DISKS
		                                                    / \
		                                                     |
		                                                     |
		                                                     |
		                                                     |
	                -------------------------------------------------------------------------------------------
	                |    Platter                                                         Platter              |
	                -------------------------------------------------------------------------------------------
	                       / \                                                             / \
	                        |								|
                                |								|
	                        |								|
	                        |								|
                       --------------------------------------------------------------------------------------------
 		       |                   Cylinders(group of similar platters on all sectors)                    |
 		       --------------------------------------------------------------------------------------------
 		              /   \                                                           /    \
 		             /     \							     /      \
 		            /       \                                                       /        \
 		      circular  circular                                              circular   circular
		       tracks    tracks                                                tracks     tracks
		               |								|
		               |								|
		               |								|
		       -------------------------------------------------------------------------------------------
		       |                           Data Blocks (Sectors)                                         |
		       -------------------------------------------------------------------------------------------
		              / \							       / \
		               |                                                                |
		               |                                                                |
		               |                                                                |
		       -------------------------------------------------------------------------------------------
                       |                                 Read by Heads                                           |
                       -------------------------------------------------------------------------------------------


	Partitioning:
		disks are divided into partitions based on physically contigious groups of sectors or cylinders.
		SCSI and SATA support up to 15 partitions, where 1-4 are primary and 5-15 logical partitions
			structure:
						Disk
						 |
						 |
						 |
						\ /
		-----------------------------------------------------------------
		|                           Drives                              |
		-----------------------------------------------------------------
		       |			|			|
		       |			|			|
		       |			|			|
	        -----------------------------------------------------------------
	        |                        Partitions                             |
	        -----------------------------------------------------------------
	        	|			|			|
	        	|			|			|
	               sda                     sdb                     sdc
	               /|\
	              / | \
	             /  |  \
	            /   |   \
	           /    |    \
	          sda1 sda2  sda3 ..


	Why Partition?
		- separation -- separating installation files from user files
		- sharing -- keeping shared resources like /home on central location
		- security -- imposing quotas, permissions and settings
		- size -- preventing accumulated data from crashing OS
		- performance --
		- swap -- hibernation schemes can use this
	Partition Table:
                - The disk partition table is contained within the Master Boot Record(MBR), and the MBR is 512bytes in length.
                  structure is defined by an operating system-independent convention.
                - The parttion table is 64 bytes long and is placed after the 446 byte boot record
                	-: structure -
                	MBR
          ---------  -----
          |          |
          |          |
          |          | 446 bytes --- GRUB program code.
          |          |
          |          |
          |          |
          |          -----
    512   |          -----
    bytes |          | Partition 1 - 16 bytes
          |          |----
          |          | Partition 2 - 16 bytes              <----Partiton Table
          |          |----
          |          | Partition 3 - 16 bytes
          |          |----
          |          | Partition 4 - 16 bytes { 0x55AA }
          |          |
          ---------  -----

          Note: each entry in the partition table 16 bytes long
          	- gives the following information:
          		- Active bit.
          		- Beginning address in cylinder/head/sectors (CHS) format (ignored by Linux)
          		- Partition type code, indicating: xfs, LVM, ntf, ext4, swap, etc.
          		- Ending address in CHS(also ignored by Linux).
          		- Start sector, counting linearly from 0.
          		- Number of sectors in partion.
          	Linux only uses the last two fields for addressing using the linear block addressing(LBA) method.

Naming Disk Devices and Nodes:
------------------------------
	The Linux kernel interacts at a low level with disks through 'device nodes' normally found in the /dev directory
	Device nodes are accessed only through the infrastructure of the kernel's Virtual File System
	SCSI and SATA:
		first hard disk is /dev/sda
		second hard disk is /dev/sdb
			partitions:
				/dev/sdb1
				/dev/sdc4
	IDE:
		/dev/hda3
		/dev/hdb
More on SCSI Device Names:
--------------------------
	- these are determined by the controller number/ID number combination.



	                               /dev/sda
	                                  /   /dev/sdb
	                                 /    /
	controller 0 => target ID number 1 & 3

        controller 1 => target ID number 2 & 5
                                          \   \
                                           \   \
                                            \  /dev/sdd
                                         /dev/sdc


blkid and lsblk:
----------------
	blkid is a utility to locate block devices and report on their attributes
	blkid works with libblkid library, takes as an argument a particular device or list of devices
	Usage:
		sudo blkid /dev/sda*
	blkid will only work on devices that contain data that is finger-printable; e.g., empty partition will not generate a block-identity UUIO
	blkid - forms of operations:
		1 - searching for a device with a specific NAME=value pair, or
		2 - displaying NAME=value pairs for one or more devices
		lsblk - will represent information in a tree format.
	Linux systems shld use a minimum of two partitions:
		- /root:
			used for the entire logical system

		- Swap:
			used as an extension of physical memory
			used as virtual memory

Backing Up and Restoring Partition Tables:
------------------------------------------
	this helps to restore the former partition of disk if new partition fails
		backup - sudo dd if=/dev/sda of=mbrbackup bs=512 count=1
		restore - sudo dd if=mbrbackup of=/dev/sda bs=512 count=1


Partition Table Editors:
------------------------
	-  fdisk: menu driven partition table editor
	-  sfdisk: non-interactive partition editor program, useful in scripting
	-  parted: GNU partition manipulation program.
	-  gparted: widely used graphical interface to parted

Using fdisk:
------------
	start: sudo fdisk /dev/sdb
		the main (one-letter) commands are:
			-m: Display the menu
			-p: List the partition table.
			-n: Create a new partition.
			-d: Delete a partion.
			-t: Change a partition type.
			-w: Write the new partition table information and exit.
			-q: Quit without making changes.
	cat /proc/partitions - will show you the partition  operating system is currently aware of.


<------------------------------------------------------------------------------------------------------->
                                Chapter 10. Encryption Disks
   Linux distributions most often use the 'LUKS' method amd perform encryption-related tasks using 'cryptsetup'.

   OBJECTIVES:
	- provide sound reasons for using encryption and know when it is called for.
	- understand 'LUKS' operations through the use of 'cryptsetup'.
	- be able to setp and use encrypted filesystems and partitions.
	- know how to configure the system to mount encrypted partitions at boot.


	Why use encryption:
	    Configuration and using block device level encryption provides one of the strongest protections agianst harm
	    caused by loss or compromise of data contained in hard drives and other media.

	    Note: Encryption can not be carried out on an already existing partition in place without a data copying operation.

	    LUKS:
		block level encryption is provided through the use of LUKS(Linux Unified Key Setup).
		LUKS is highly recommended for portable systems e.g. laptops, tablets, smartphones.

		LUKS         plain dm-crypt volumes      loop-AES     TrueCrypt
		 |	     	   	    |		   |              |
		 |			    |		   |		  |
		 |--------------------------|--------------|--------------|
						|
						|
						v
					    cryptsetup
                 LUKS stores all necessary information in the partition header itself, it is rather easy to migrate partitions to other disks or systems.
		 LUKS can also be used to transparently encrypt swap partitions.

     Cryptsetup:
	command format -
		cryptsetup [option...] <action> <action-specific>
		listing possibilities ->
		cryptset --help
    Using an Encrypted Partition:
    	if the LVM partition '/dev/VG/MYSECRETE already exists the following steps will setup encryption
	--> 1. Make it available to LUKS
	    2. format it
	    3. mount it
	    4. use it
	    5. unmount it
        -->
		sudo cryptsetup luksFormat /dev/VG/MYSECRET -- (if kernel doesn't support the default method used by 'cryptsetup' use sudo cat /proc/crypto to find out which your system supports)
	    	 sudo cryptsetup luksFormat --cipher aes /dev/VG/MYSECRET
	    	 sudo cryptsetup --verbose luksOpen /dev/VG/MYSECRET SECRET
	    	 sudo mkfs.ext4 /dev/mapper/SECRET
	    mount it -->
	    	 sudo mount /dev/mapper/SECRET /mnt
	    unmount it -->
	         sudo umount /mnt
            remove the mapper -->
                 sudo cryptsetup --verbose luksClose SECRET


     Mounting at Boot:
     	    Steps include -->
	    	  - make appropraite entry in /etc/fstab
		  - add entry to /etc/crypttab
		    --such as 'SECRET /dev/mapper/MYSECRET

     Steps for Using LUKS:
     	   - create a partition for the encrypted block device
	   - format with cryptsetup
	   - create an un-encrypted pass through device
	   - format with a standard filesystem such as ext4
	   - mount the filesystem on the encrypted block device


<------------------------------------------------------------------------------------------------->

                  Chp11. Linux Filesystems and the VFS( Virtual File System )

Structure of Linux file system:

	  software <-----> VFS <-----> on-disk filesystem

Objectives:
	- explain the basic filesystem organization.
	- understand the role of the VFS.
	- know what filesystema are available in Linux and which ones can be used on your actual system.
	- grasp why journaling filesystem represent significant advances.
	- discuss the use of special filesystems in Lunux.

Local filesystems generally reside within a disk partition which can be a physical partition on a disk, or a logical partition controlled by a LOGICAL VOLUME MANAGER (LVM).
Filesystems can also be of a network nature and their true physical embodiment completely hidden to the local system across the network.

VFS:
	user software <---------> VFS <---------> actual filesystem
	     	      		   |
				   |
				   |
				   v
			/dev, /sys, /temp, /proc, /run

Journalling Filesystems:
	    These recover from system crashes or ungraceful shutdowns with little or no corruption, and they do so very rapidly.
	    Here operations are grouped into transactions, each must be completeed without error, atomically; otherwise the filesystem is not changed.
	    Examples include:
	    	     - ext3, extension of ext2
		     - ext4, enhanced ext3
		     - reiserfs, formally for linux
		     - JFS, IBM
		     - XFS, RHEL
		     - btrfs, latest journalling filesystem under rapid development.
Current Filesystem Types:
	to see system currently registered and understood filesystem.
	cat /proc/filesystems

Special Filesystems:
	Filestsystem     |        Mount Point        |      Purpose
	------------------------------------------------------------------------------------
	rootfs			None			During kernel load, provides an empty root directory.
	hugtlbfs		Anywhere		Provides extended page access (2 or 4 MB on x86)
	bdev			None			Used for block devices.
	proc			/proc			Pseudo filesystem access to many kernel structures and aubsystems.
	sockfs			None			Used by BSD Sockets.
	tmpfs			Anywhere		RAM disk with swapping, re-sizing.
	shm			None			Used by System C IPC Shared Memory.
	pipefs			None			Used for pipes.
	binfmt_misc		Anywhere		Used by various executable formats.
	devpts			/dev/pts		Used by Unix98 pseudo-termionals.
	usbfs			/proc/bus/usb		Used ny USB sub-system for dynamical devices.
	sysfs			/sys (or elsewhere)	Used as a device tree.
	debugfs			/sys/kernel/debug (or	Used for simple debugging file access.
				elsewhere)


<---------------------------------------------------------------------------------------------------------------->

			Chpt.12. Filesystem Features: Attributes, Creating, Checking, Mounting
	Objectives:
		- be familiar with concepts such as inodes, directory files and extended attributes.
		- create and format filesystems.
		- check and fix errors on filesystems.
		- mount and unmount filesystems.

	Inodes:
		is a data structure on disk that describes and stores file attributes, including location.
		the ionformation stored includes --
		    > permissions
		    > user and group ownership
		    > size
		    > timestamps (nanoseconds)
		      - last access time
		      - last modification time
		      - change time

	Directory Files:
		  is a particualr type of file that is used to associate file names and inodes.
		  two ways to associate (or link) a file name with an inode:
		      > HARD links point to an inode.
		      > SOFT (or symbolic) links point to a file name which has an associated inode.

		  process references pathname ---> kernel [searches directories to find corresponding inode number]
		  	  	     	      	   	  	    		|
										|
										|
										v
							converts name to inode number ---> loads into memory
	Extended Attributes and lsattr/chattr:
		 extended attributes associate not interpreted directly by the filesystem with files.
		 Namespaces used in fileattributes:
		 	    > user,
			    > trusted,
			    > system - access control list (ACL),
			    > security- SELinux.

		format:	    chattr [-|+|=mode] filename (change attribute)
			    lsattr filename   (list file attribute)
	        Namespaces:
			user --
			     flags --> i: immutable, a: append-only, d: no-dump, A: No atime update

       Creating anf Formatting Filesystems:
       		utility for formatting (making) filesystem on a partition is 'mkfs'
		format --> mkfs [-t fstype] [options] [device name], e.g.: sudo mkfs -t ext4 /dev/sda10 OR sudo mkfs.ext4 /sda10

       Checking and Fixing Filesystems:
       		utility for checking and fixing any errors in a filesystem is 'fsck'
		format --> sudo fsck -t ext4 /dev/sda10 OR sudo fsck.ext4 /dev/sda10
		       --> fsck [-t fstype] [options] [device-file]
		Note: SHOULD ONLY BE RUN ON UNMOUNTED FILESYSTEMS.
		to do so run the following command --> sudo touch /forcefsck, sudo reboot


      Mount:
		Each file system is mounted under a specific directory as in:
		--> sudo mount -t ext4 /dev/sdb4 /home

		mounting files using label or a UUID
		--> sudo mount /dev/sdb4 /home
		--> sudo mount LABEL=home /home
		--> sudo mount  -L home /home
		--> sudo mount UUID=26d58ee2-94jjjfhv0-vnskjs-44ns48 /home
		--> sudo mount -U UUID=26d58ee2-94jjjfhv0-vnskjs-44ns48 /home
		with mount --help you get a quick summary of mount options

     unmount:
		umount [device-file | mount-point]
		--> sudo umount /home
		--> sudo umount /dev/sda3

     Mounting Filesystem at Boot:
     	        this command will show you how to mount all filesystems listed in the /etc/fstab at boot
	        --> cat /etc/fstab

     Listing Currently Mounted Filesystems:
     	        --> mount

     Notes:
	format filesystems --> mkfs
	checking and fixing errors --> fsck
	list file attributes --> lsattr
	change file attribute --> chattr
	list open files --> lsof


  <-------------------------------------------------------------------------------------------------------------------->

                                Chapter 13. Filesystem Features: Swap, Quotas, Usage.

  Linux uses robust 'swap space' implementation through which the virtual memory system permits the apparent use of memory than is physically available.

  Filesystem quotas can be used to administer user account usage of disk space.
  Utilities such as 'df' and 'du' enable easy monitoring of filesystem usage and capacities.


  Objectives:
    - explain the concepts of swap and quotas.
    - use the utilities that help manage quotas: quotacheck, quotaon, quotaoff, edquota, and quota.
    - use the utilities df and du.

  Swap:
    virtual memory in Linux uses the COW(Copy On Write) technique ie:
                PARENT memory
                      ^
                      |
                      |
                      |
            |---------|----------|-----------------|
          child A   child B    child C          child D --> [extra memory sector since a portion of PARENT has changed]

          - when memory pressure is high 'less active memory regions are swapped out to disk' and only recalled when needed.

    - In most cases the recommend swap size is the RAM
    - to see what ure system is currently using for swap areas: $ cat /proc/swaps
                                          and current usage: $ free -o

    - commands invovling swap are:
        - mkswap: format a swap partition or file
        - swapon: activate a swap partition or file
        - swapoff: deactivate a swap partition or file
  Quotas:
    - quotacheck:- generates and updates quota accounting files
    - quotaon:- enable quota accounting
    - quotaoff:- disables quota accounting
    - edquota:- used for editing user of group quotas.
    - quotas:- reports on usage and limits.

    Note:
      Quota operations require the existence of the files 'aquota.user and aquota.group' in the root directory of the filesystem using quotas.

    Setting up Quotas:
      - steps include:-
            -- mount the filesystem with user and/or group quota options:
                --- add the userquota and/or grpquota options to the filesystem entry in /etc/fstab
                --- remount the filesystem (or mount it if new)
            -- run 'quotacheck' on the filesystem to set up quotas.
            -- enable quotas on the filesystem
            -- set quotas with the edquota program.

    Setting up Quotas:
      - in /etc/fstab:- /dev/sda5 /home ext4 defaults,usrquota 1 1
      - then test the system:
        -- sudo mount -o remount /home
        -- sudo quotacheck -vu /home
        -- sudo quotaon -vu /home
        -- sudo edquota someuser

      - fstab options include: usrquota and grpquota

    quotacheck:
      creates/updates the quota accounting files aquota.user and aquota.group for the system

    - to update user files for all filesystems in /etc/fstab with user quota options:
      $ sudo quotacheck -ua

    - to update group files for all filesystems i /etc/fstab with group quota options:
      $ sudo quotacheck -ga

    - to update the user file for a particular filesystem:
      $ sudo quotacheck -u [somefilesystem]

    - to update the group file for a particular filesystem:
      $ sudo quotacheck -g [somefilesystem]

    Note: use -v option to get more verbose output
    Note: quotacheck is generally run:-
          -- when quotas are turned on
          -- fsck reports errors during system start up

    Turning quotas on and off:
      - syntax:
        -- $ sudo quotaon [flags] [filesystem]
        -- $ sudo quotaoff [flags] [filesystem]
          --- where the flags can be:
              -a, --all                 turn off for all filesystems
              -f, --full                turn off
              -u, --user                operate on user quotas
              -g, --group                         "
              -p, --print-state         print whether quotas are on or off
              -x, --xfs-command=cmd     perform XFS quota command
              -F, --format=formatname   operate on specific quota format
              -v, --verbose             print more messgaes
              -h, --help                display help text and exit
              -V, --version             display version information

        -- sudo quotaon -av /dev/sda6 / : group quotas turned on
        -- sudo quotaon -av /dev/sda6 /home : user quotas turned on
        -- sudo quotaoff -av /dev/sda6 / : group quotas turned off
        -- sudo quotaoff -av /dev/sda6 /home : user quotas turned off
        -- sudo quotaon -avu /dev/sda6 /home : user quotas turned on
        -- sudo quotaoff -avu /dev/sda6 /home : user quotas turned off
        -- sudo quotaon -avg /dev/sda6 /home : group quotas turned on
        -- sudo quotaoff -avg /dev/sda6 /home : group quotas turned off

        Note: quota operations will fail if aquota.user and aquota.group do not exist

  Examining Quotas:
    - quota ( or quota -u) for current user
    - quota -g returns ure current group quota
    - with superuser for any user:
            -- sudo quota george
            -- sudo quota gracie

  Setting Quotas:
    only fields that can be modofied are 'soft and hard limits' only
    - edquota -u [username]
    - edquota -g [groupname]
    - edquota -u -p [userproto] [username] : used in scripts
    - edquota -u -p [groupproto] [groupname] : used in scripts
    - edquota -t : to set grace periods

    Note: soft limits may be exceeded for a grace period, hard limits may never be exceeded

  Filesystem Usage:
    df (disk free) examines filesystem capacity and usage
    df -hTi

  Diskspace Usage:
    du (disk usage) shows how much space a directory and its subdirectories are using on a filesystem
    - For current directory: $ du
    - to list all files not directories alone: $ du -a
    - human readable format: $ du -h
    - for specific directory: $ du -h somedir
    - display  only totals: $ du -s



<------------------------------------------------------------------------------------------------------->

                    Chapter 14. The Ext2/Ext3/Ext4 Filesystems

  Most used filesystem, with the ext4 being the latest version.


  Objectives:
    - describe the main features of the ext4 filesystem and how it is laid out on disk.
    - explain the concepts of block groups, superblock, data blocks and inodes.
    - Use the dumpe2fs and tune2fs utilities.
    - list the ext4 filesystem enhancements.

  Ext4 History and Basics:
    Timeline:--> ext2 --> ext3 (with journalling) --> ext4 (extents added for large filesystems)
    RHEL 7 uses XFS as default

  Ext4 Features:

            ext4
              |
              |
            blocks --->[512, 1024, 2048, 4096]
              |
        Pages of Memory -->[x86(4kb page size), x64(8kb page size)]


  Ext4 Layout:

              Disk Blocks
                  |
                  |
              Block Groups0 - n
                  |
      |-------------------------------------------------|
      |                                                 |
  block grp 0                                       block grp 1- n (boot sector is absent)
      |
    |-----------------------------|------------------------|----------------|-----------------|---------------|-----------|
    1024(boot sector)        Superblock             Grp Descriptors  Data block bitmap    inode bitmap   inode Table  data blocks
                                  |                                                                                       |
                                  |                                                                                       |
                                  |                                                                                 pre-allocated to files to improve speed
                                  |
                                  |
                                  |
                                  bit-fields:
                                    used to:
                                      -- ascertain whether or not the FS requires checking when first mounted
                                      -- determine when FS was last checked, both in date and number of mounts

  Block Groups:
    Same as above


  dumpefs:
    - scan filesystem information
    $ sudo dumpe2fs /dev/sda2

  tune2fs:
    -- used to change filesystem parameters
      --- change the maximum number of mounts between filesystem checks(max-mount-count)
          $ sudo tune2fs -c 25 /dev/sda2
      --- change the time interval between checks (interval-between-checks)
          $ sudo tune2fs -i 10 /dev/sda2

      --- list the contents of the superblock including current values of parameters whwich can be changed:
          $ sudo tune2fs -l /dev/sda2


  Superblock Information:
    Contains information about the filesystem including:
        -- mount count and maximum count, set by tune2fs.
        -- block size, set by mkfs
        -- blocks per group
        -- free block count
        -- free inode count.
        -- operating system ID


  Data Blocks and Inodes:
    these are blocks whose bits contain 0 for each free block ot inode and 1 for eachused one.

  Ext4 Filesystem Enhancements:
    - is backwards-compatible with ext3 and ext2
    - increases the maximum fielsystem size to 1 EB (from 16 TB), and the maximum file to 16 TB (from 2 TB).
    - INCREASE WITHOUT LIMIT THE MAXIMUM NUMBER OF SUBDIRECTORIES, WHICH WAS LIMITED TO 32K IN EXT3
    - SPLITS LARGE FILES INTO THR LARGEST POSSIBLE EXTENTS INSTEAD OF USING INDIRECT BLOCK MAPPING.
    - USES MULTIBLOCK ALLOCATION
    - PRE-ALLOCATE DISK SPACE FOR A FILE
    - USES ALLOCATE-ON-FLUSH
    - USES FAST FSCK
    - USES CHECKSUMS FOR THE JOURNAL WHICH IMPROVES RELIABILITY
    - USES IMPROVED TIMESTAMPS WHICH IS MEASURED IN NANOSECONDS
    - INCLUDES SNAPSHOT SUPPORT.


<--------------------------------------------------------------------------------------------------------------------------------->

                    CHAPTER 15. THE XFS AND BTRFS FILESYSTEMS.

  THESE ARE IMPORTANT CHALLENGERS TO THE EXT4 FILESYSTEM.

  OBJECTIVES:
    - DESCRIBE THE XFS FILESYSTEM
    - MAINTAIN THE XFS FILESYSTEM
    - DESCRIBE THE BTRFS FILESYSTEM

  XFS FILESYSTEM:
    ORIGINALLY MADE BY SGI FOR IRIX OS
    - ADVATAGES INCLUDE:
      -- HANDLE:
          --- UP TO 16EB(EXABYTES) FOR THE TOTAL FILESYSTEM
          --- UP TO 8EB(EXABYTES) FOR AN INDIVIDUAL FILE
      -- HIGH PERFORMANCE:
          --- EMPLOYING DMA(DIRECT MEMORY ACCESS) I/O
          --- GUARANTEEING AN I/O RATE
          --- ADJUSTING STRIPE SIZE TO MATCH UNDERLYING RAID OR LVM DEVICES
      -- CAN JOURNAL QUOTA INFORMATION, BUT LEADS TO DECREASE IN RECOVERY TIME WHEN A QUOTA-ENABLED FILESYSTEM IS UNCLEANLY UNMOUNTED
      -- SUPPORTS EXTENDED ATTRIBUTES

  XFS FILESYSTEM MAINTENANCE:
    - ADVANTAGE:
      -- MOST MAINTENANCE TASKS CAN BE DONE ON-LINE WHILE THE FILESYSTEM IS FULLY MOUNTED, THESE INCLUDE:
          --- DEFRAGMENTING
          --- ENLARGING
          --- DUMPING/RESTORING
      -- BACKUP AND RESTORE CAN BE DONE WITH THE NATIVE XFS UTILITIES:
        --- XFSDUMP
        --- XFSRESTORE

  THE BTRFS FILESYSTEM:
    B-TREE FILE SYSTEM:
      - ADVANTAGES:
          -- ADDRESSES THE LACK OF:-
              --- POOLING,
              --- SNAPSHOTS,
              --- CHECKSUMS, AND
              --- INTEGRAL MULTI-DEVICE SPANNING

  <------------------------------------------------------------------------------------------------------------------->

                          CHAPTER 16. LOGICAL VOLUME MANAGEMENT(LVM)

  - PERMITS HAVING ONE LOGICAL FILESYSTEM SPAN MUTIPLE PHYSICAL VOLUMES AND PARTITIONS WHILE APPEARING AS A SIMPLE PARTITION FOR NORMAL USE.
  - MAKES SHRINKING AND EXPANDING EASY

  OBJECTIVES:
    - EXPLAIN THE CONCEPTS BEHIND LVM
    - CREATE LOGICAL VOLUMES
    - DISPLAY LOGICAL VOLUMES
    - RESIZE LOGOCAL VOLUMES
    - USE LVM SNAPSHOTS

  LVM:
    - BREAKS UP ONE VIRTUAL PARTITION INTO MULTIPLE CHUNKS, EACH OF WHICH CAN BE ON DIFFERENT PARTITIONS AND/OR DISKS.
    - TYPICAL LVM STRUCTURE OR LAYOUT
    - STRIPING (SPLITTING OF DATA TO MORE THAN ONE DISK)

  |-----------------------------------------------------------------------------------------------------------|
  |                                                         LVM                                               |
  |                       ------------------------------------------------------------------------------|     |
  |         FILE SYSTEMS  |          /HOME(EXT3)              ||                /DATA(XFS)              |     |
  |                       |-----------------------------------------------------------------------------|     |
  |  LOGICAL VOLUMES(LV)  | /DEV/PRIMARY_VG/HOME_|V           ||      /DEV/PRIMARY_VG/DATA_|V           |     |
  |                       |-----------------------------------------------------------------------------|     |
  |   VOLUME GROUPS(VG)   |                           PRIMARY_VG                                        |     |
  |                       |-----------------------------------------------------------------------------|     |
  |   PHYSICAL VOLUMES    | /DEV/SDB1   ||   /DEV/SDB2        ||     /DEV/SDC1     ||   /DEV/SDC2       |     |
  |                       |-----------------------------------------------------------------------------|     |
  |-----------------------------------------------------------------------------------------------------------|

     PARTITIONS           |---------------||-------------|              |----------------||-------------------|
                          | /DEV/SDB1     || /DEV/SDB2   |              |  /DEV/SDC1     ||   /DEV/SDC2       |
                          |---------------||-------------|              |----------------||-------------------|
                          |------------------------------|              |-------------------------------------|
    PHYSICAL DRIVES       |             /DEV/SDB         |              |                /DEV/SDC             |
                          |------------------------------|              |-------------------------------------|



  LVM AND RAID:
    - LVM CAN BE BUILT ON RAID

  VOLUMES AND VOLUME GROUP:
    - COMMANDS:
      -- VGCREATE: CREATE VOLUME GROUP
      -- VGEXTEND
      -- VGREDUCE
      -- PVCREATE: CONVERT A PARTITION TO A PHYSICAL VOLUME
      -- PVDISPLAY: SHOWS THE PHYSICAL VOLUME
      -- PVMOVE: MOVES THE DATA FROM ONE PHYSICAL VOLUME GROUP TO OTHERS
      -- PVREMOVE

  LOGICAL VOLUMES UTILITIES:
    - $ LS -LF /SBIN/LV* --> DOESN'T WORK ON UBUNTU TRUSTY

  CREATING LOGICAL VOLUMES:
    - COMMANDS:
      -- LVCREATE --> ALLOCATES LOGICAL VOLUMES FROM WITHIN VOLUME GROUPS
      -- LVDISPLAY --> REPORTS ON AVAILABLE LOGOICAL VOLUMES
    - FILESYSTEMS ARE PLACED IN LOGICAL VOLUMES AND ARE FORMATTED WITH MKFS AS USUAL
    - STEPS:
       -- CREATE PARTITIONS ON DISK DRIVES (TYPE 8E IN FDSIK)
       -- CREATE PHYSICAL VOLUMES FROM THE PARTITIONS                  --> $ SUDO PVCREATE /DEV/SDC1
       -- CREATE THE VOLUMES GROUP                                     --> $ SUDO VGCREATE -S 16M VG /DEV/SDB1
       -- ALLOCATE LOGICAL VOLUMES FROM THE VOLUME GROUP               --> $ SUDO LVCREATE -L 50G -N MYLVM VG
       -- FORMAT THE LOGICAL VOLUMES                                   --> $ SUDO MKFS -T EXT4 /DEV/VG/MYLVM
       -- MOUNT THE LOGICAL VOLUMES (ALSO UPDATE /ETC/FSTAB AS NEEDED) --> $ MKDIR /MYLVM, THEN --> $ SUDO MOUNT /DEV/VG/MYLVM /MYLVM, THEN --> /DEV/VG/MYLVM /MYLVM EXT4 DEFAULTS 0 0 ( TO THE /ETC/FSTAB)

  DISPLAYING LOGICAL VOLUMES:
    - SUDO PVDISPLAY OR SUDO PVDISPLAY /DEV/SDA5
    - SUDO VGDISPLAY OR SUDO VGDISPLAY /DEV/VG0
    - SUDO LVDISPLAY OR SUDO LVDISPLAY /DEV/VG0/LVM1

  RESIZING LOGICAL VOLUMES:
    -- WITH FS:
        -- SHRINK --> 1. SHRINK FS 2. SHRINK VOLUME
        -- EXPAND --> 1. EXPAND VOLUME, 2. EXPAND FS
    -- UTILITY: RESIZEFS
  EXAMPLES OF RESIZING:
        SUDO LVEXTEND -L +500M /DEV/VG/MYLVM
        SUDO RESIZEFS /DEV/VG/MYLVM

    - SHRINK:
        SUDO UMOUNT /MYLVM
        SUDO FSCK -F /DEV/VG/MYLVM
        SUDO RESIZEFS /DEV/VG/MYLVM 200M
        SUDO LVREDUCE -L 200M /DEV/VG/MYLVM
        SUDO MOUNT /DEV/VG/MYLVM

    - NEW VERSIONS OF LVM UTILITY:
      -- SUDO
      -- SUDO LVEXTEND -R -L +100M /DEV/VG/MYLVM
      -- SUDO LVREDUCE -R -L -100M /DEV/VG/MYLVM

    - VOLUME GROUP:
      -- SUDO PVMOVE /DEV/SDC1
      -- SUDO VGREDUCE VG /DEV/SDC1


  LVM SNAPSHOTS:
    - CREATES AN EXACT COPY OF AN EXISTING LOGICAL VOLUME
    - USEFUL FOR:
      -- BACKUPS, APPLICATION TESTING, AND DEPLOYING VMS
    - CREATING SNAPSHOTS:
      -- SUDO LVCREATE -L 128 -S -N MYSNAP /DEV/VG/MYLVM
      --- MAKE A MOUNT POINT AND MOUNT THE SNAPSHOT:
          ---- MKDIR /MYSNAP
          ---- MOUNT -O RO /DEV/VG/MYSNAP /MYSNAP
      --- TO USE AND REMOVE SNAPSHOT:
          ---- SUDO UMOUNT /MYSNAP
          ---- SUDO LVREMOVE /DEV/VG/MYSNAP


<--------------------------------------------------------------------------------------------------------------------------->

									CHAPTER 17. RAID

- THE USE OF RAID SPREADS I/O ACTIVITY OVER MULTIPLE PHYSICAL DISKS, RATHER THAN JUST ONE.
- ITS PURPOSE IS TO ENHANCE DATA INTEGRITY AND RECOVERABILITY IN CASE OF FAILURE, AS WELL AS TO BOOST PERFORMANCE WHEN USED WITH MODERN
	STORAGE DEVICES.
- RAID HAS DIFFERENT LEVELS WITH VARY IN THEIR RELATIVE STRENGTHS IN SAFETY, PERFORMANCE, COMPLEXITY AND COST.

OBJECTIVES:
	- EXPLAIN THE CONCEPT OF RAID.
	- SUMMARIZE RAID LEVELS.
	- CONFIGURE A RAID DEVICE USING THE ESSENTIAL STEPS PROVIDED.
	- MONITOR RAID DEVICES IN MULTIPLE WAYS.
	- USE HOT SPARES.

RAID:
	- MEANING REDUNTANT ARRAY OF INDEPENDENT DISK
	- RAID CAN BE IMPLEMENTED IN 'SOFTWARE' OR IN 'HARDWARE'
	- SIMPLE IMPLEMENTATION:-

			512GB HARD DRIVES ---> RAID SOFTWARE IMPLEMENTATION ---> 1TB DISK

	- DISADVANTAGE OF RAID HARDWARE:
		-- IF DISK CONTROLLER FAILS, IT MUST BE REPLACED BY A COMPATIBLE CONTROLLER UNLIKE SOFTWARE IMPLEMENTATION
			WHICH CAN ALLOW THE DISK TO WORK WITH ANY CONTROLLER.
	- THE ESSENTIAL FEATURES OF RAID ARE:
		-- MIRRORING: WRITING THE SAME DATA TO MORE THAN ONE DISK.
		-- STRIPING: SPLITTING OF DATA TO MORE THAN ONE DISK.
		-- PARITY: EXTRA DATA IS STORED TO ALLOW PROBLEM DETECTION AND REPAIR, YIELDING FAULT TOLERANCE.
		-- THUS USE OF RAID CAN IMPROVE BOTH PERFORMANCE AND RELIABILITY.
	- RAID DEVICES ARE TYPICALLY CREATED BY COMBINING PARTITIONS FROM SEVERAL DISKS TOGETHER
	- MDADM IS USED TO CREATE AND MANAGE RAID DEVICES, '/DEV/MDX' IS EQUIVALENT TO '/DEV/SDA1'
RAID LEVELS:
	- MANY LEVELS EXISTS BASED ON THE SPECIFICATION OF INCREASING COMPLEXITY AND USE, THESE ARE:
		-- RAID 0: USES ONLY STRIPING.
			--- ADVANTAGES:
				---- DATA SPREAD ACROSS MULTIPLE DISKS
				---- IMPROVED PERFORMANCE
			--- DISADVANTAGES:
				---- NO REDUNDANCY
				---- NO STABILITY
				---- NO RECOVERY CAPABILITIES
		-- RAID 1: USES ONLY MIRRORING
			--- ADVANTAGES:
				---- GOOD FOR RECOVERY AS EACH DISK HAS A DUPLICATE
		-- RAID 5: USES ROTATING PARITY STRIP;
			--- ADVANTAGE:
				---- DISK FAILURE ONLY CAUSES DROP IN PERFORMANCE, NO LOSS OF DATA
				--NOTE: THEY MUST BE AT LEAST 3 DISKS
		-- RAID 6: HAS STRIPED DISKS WITH DUAL PARITY,
			--- CAN HANDLE LOSS OF TWO DISKS
			--- REQUIRES AT LEAST 4 DISKS
			--- REPLACES RAID 5 DUE TO ITS STRESS ON HARDWARE
		-- RAID 10: IS A MIRRORED AND STRIPED DATA SET.
			--- AT LEAST 4 DRIVES ARE NEEDED.
		NOTE: ADDING MORE DISKS IMPROVES PERFORMANCE.
SOFTWARE RAID CONFIGURATION:
	- STEPS FOR SETUP INCLUDES:
		-- CREATE PARTITIONS ON EACH DISK (TYPE FD IN FDISK)
		-- CREATE RAID DEVICE WITH MDADM
		-- FORMAT RAID DEVICE
		-- ADD DEVICE TO /ETC/FSTAB
		-- MOUNT RAID DEVICE
		-- CAPTURE RAID DETAILS TO ENSURE PERSISTENCE
	- THE COMMAND: SUDO MDADM -S --> USED TO STOP RAID
	- EXAMPLE:
		- CREATE TWO PARTITIONS OF TYPE FD ON DISKS /DEV/SDB, /DEV/SDC
			-- SUDO FDISK /DEV/SDB, SUDO FDISK /DEV/SDC
		- SET UP THE ARRAY
			-- SUDO MDADM --CREATE /DEV/MD0 --LEVEL=1 --RAID-DISKS=2 /DEV/SDBX /DEV/SDCX
		- FORMAT IT
			-- SUDO MKFS.EXT4 /DEV/MD0
		- ADD TO CONFIGURATION
			-- SUDO BASH -C "MDADM --DETAIL --SCAN >> /ETC/MDADM.CONF"
		- MOUNT IT
			-- SUDO MKDIR /MYRAID
			-- SUDO MOUNT /DEV/MD0 /MYRAID
			-- ADD /DEV/MD0 /MYRAID EXT4 DEFAULTS 0 2
		- EXAMINE /PROC/MDSTAT TO SEE THE RAID STATUS AS IN:
			-- CAT /PROC/MDSTAT
		- TO STOP
			-- SUDO MDADM -S /DEV/MD0

MONITORING RAIDS:
	- WAYS INCLUDE:
		-- SUDO MDADM --DETAIL /DEV/MD0
		-- CAT /PROC/MDSTAT
		-- YOU CAN ALSO USE: MDMONITOR, REQUIRES THE CONFIGURATION OF /ETC/MDADM.CONF
		-- STATUS OF RAID DEVICE /DEV/MDX:
			--- SUDO MDADM --DETAIL /DEV/MDX
		-- SHOW STATUS OF ALL RAID DEVICES ON THE SYSTEM
			-- CAT /PROC/MDSTAT
		-- MONITOR RAID VIA EMAIL:
			--- MAILADDR EDDIE@HASKEL.COM
			--- STARTING EMAIL SERVICE WITH:
				---- SUDO SERVICE MDMONITOR START
				---- SUDO CHKCONFIG <MDMONITOR | MDADM> ON

RAID HOT SPARES:
	- USED TO FIX REDUNDANCIES
	- CREATE HOT SPARES FOR RAID
		-- SUDO MDADM --CREATE /DEV/MD0 -L 5 -N3 -X 1 /DEV/SDA8 /DEV/SDA9 /DEV/SDA10 /DEV/SDA11
		-- SWITCH '-X 1' TELLS RAID TO USE ONE HOT SPARES
		-- TESTING THE REDUNDANCY AND HOT SPARE OF YOUR ARRAY
			--- SUDO MDADM --FAIL /DEV/MD0 /DEV/SDB2
		-- RESTORING TESTED DRIVE:
			--- SUDO MDADM --REMOVE /DEV/MD0 /DEV/SDB2
			--- SUDO MDADM --ADD /DEV/MD0 /DEV/SDE2

<---------------------------------------------------------------------------------------------------->

						CHAPTER 18. LOCAL SYSTEM SECURITY

OBJECTIVES:
	- ASSESSING SYSTEM SECURITY RISKS
	- FASHION AND IMPLEMENT SOUND COMPUTER SECURITY POLICIES AND PROCEDURES
	- EFFICIENTLY PROTECT BIOS AND THE BOOT LOADER WITH PASSWORDS
	- USE APPROPRAITE MOUNT OPTIONS, SETUID AND SETGID TO ENHANCE SECURITY
LOCAL SYSTEM SECURITY:
	- CAN BE DEFINED IN TERMS OF:
		-- THE SYSTEMS ABILITY TO REGURALARLY DO WHAT IT IS SUPPOSED TO DO
		-- INTEGRITY AND CORRECTNESS OF SYSTEM
		-- ENSURING THAT THE AYATEM IS ONLY AVAILABLE TO THOSE AUTHORIZED TO USE IT

	- AREAS FOR SECURITY INCLUDE:
		-- PHYSICAL
		-- LOCAL
		-- REMOTE, AND PERSONAL
CREATING A SECURITY POLICY:
	- BASIC STRUCTURE OF COMPUTER SECURITY:
		-- BE SIMPLE AND EASY TO UNDERSTAND
		-- GET CONSTANTLY UPDATED
		-- BE IN THE FORM OF A WRITTEN DOCUMENTATION
		-- DESCRIBE BOTH POLICIES AND PROCEDURES
		-- SPECIFY ENFORCEMANT ACTIONS
		-- SPECIFY ACTIONS TO TAKE IN REESPONSE TO A SECURITY BREACH
	- BASIC STRUCTURE OF SECURITY POLICIES:
		-- SHOULD BE GENERIC SO ITS EASY TO FOLLOW
		-- MUST SAFE THE DATA THAT NEEDS PROTECTIONS
		-- DENY ACCESS TO REQUIRED SERVICES AND PROTECT USER POLICY
	- POLICIES SHOULD BE UPDATED ON A REGULAR BASIS
WHAT TO INCLUDE IN THE POLICY:
	- METHODS OF PROTECTING INFORMATION FROM BEING READ OR COPIED BY UNAUTHORIZED PERSONEL
	- PROTECTION OF INFORMATION FROM BEING ALTERED OR DELETED WITHOUT THE PERMISSION OF THE OWNERSHIP
	- ALL SERVICES SHOULD BE PROTECTED SO THEY ARE AVAILABLE AND NOT DEGRADED IN ANY MANNER WITHOUT AUTHORIZATION
	- ASPECTS INCLUDE:
		-- CONFIDENTIALITY
		-- DATA INTEGRITY
		-- AVAILABILITY
		-- CONSISTENCY
		-- CONTROL
		-- AUDIT
WHAT RISKS TO ASSESS:
	- QUESTIONS ARE:
		-- WHAT DO I WANT TO PROTECT?
		-- WHAT AM I PROTECTING IT AGAINST?
		-- HOW MUCH TIME, PERSONNEL, AND MONEY IS NEEDED TO PROVIDE ADEQUATE PROTECTION?
CHOOSING A SECURITY PHILOSOPHY:
	- BASIC PHILOSOPHIES:
		-- ANYTHING NOT EXPRESSLY PERMITTED IS DENIED
		-- ANYTHING NOT EXPRESSLY FORBIDDEN IS PERMITTED
SOME GENERAL SECURITY GUIDLINES:
	- GENERAL GUIDELINES:
		-- HUMAN FACTOR IS THE WEAKEST LINK:
			--- EDUCATE YOUR USERS AND KEEP THEM HAPPY
		-- NO COMPUTER ENVIRONMENT IS INVULNERABLE
		-- PARANOIA IS A GOOD THING:
			--- BE SUSPICIOUS, VIGILANT, PERSEVERE WHEN SECURING A COMPUTER.
UPDATES AND SECURITY:
	- ALWAYS APLY UPDATES AND UPGRADES
HARDWARE ACCESSIBILITY AND VULNERABILITY:
	- PHYSICAL ACCESS TO SERVERS AND WORKSTATIONS SHOULD MONITORED
HARDWARE ACCESS GUIDELINES:
	- STEPS INCLUDE:
		-- LOCKING DOWN WORKSTATIONS AND SERVERS
		-- PROTECTING YOUR NETWORK LINKS AGAINST ACCESS BY PEOPLE YOU DO NOT TRUSTED
		-- PROTECTING YOUR KEYBOARDS WHERE PASSWORDS ARE ENTERED TO ENSURE THE KEYBOARDS CANNOT BE TAMPERED WITH
		-- PASSWORD PROTECTING BIOS TO PREVENT BOOTING FROM LIVE OR RESCUE CD/DVD OR USB KEY

PROTECTION OF BIOS:
	- SHOULD BE DONE WITH CARE

PROTECTING THE BOOT LOADER WITH PASSWORD:
	- SHOULD BE SECURED WITH THE BIOS FOR FULL PROTECTION
	- STEPS INCLUDES:
		-- GRUB VERSION 1:
			--- RUN GRUB-MD5-CRYPT
			--- COPY DISPLAYED HASHED PASSWORD
			--- EDIT /BOOT/GRUB/GRUB.CONF AND ADD THE LINE BELOW THE TIMEOUT ENTRY:
				---- PASSWORD --MD5 $LKL(8R8LKZ.LJGSOORP)I4MMKKKLXZA
		-- GRUB VERSION 2:
				--- MORE COMPLICATED TO SET UP
				--- EDIT SYSTEM CONFIGURATION FILES IN /ETC/GRUB.D
				--- RUN UPDATE-GRUB
FILESYSTEM SECURITY: MOUNT OPTIONS:
	- NODEV --> DO NOT INTERPRET CHARACTER OR BLOCK SPECIAL DEVICES ON THE SYSTEM
	- NOSUID --> THE SET-USER-IDENTIFIER OR SET-GROUP-IDENTIFIER BITS DO NOT TAKE EFFECTIVE
	- NOEXEC --> RESTRIC DIRECT EXECUTION OF ANY BINARIES ON THE MOUNTED FILESYSTEM
	- RO --> MOUNT THE FILESYSTEM IN READ-ONLY MODE AS IN:
		-- MOUNT -O RO,NOEXEC,NODEV /DEV/SDA2 /MYMOUNTPT
		OR
		-- /DEV/SDA2 /MYMOUNTPT EXT4 RO,NOEXEC,NODEV 0 0

SETUID AND SETGID:
	- USING THIS COMMANDS ONE CAN CHANGE THE DEFAULT BEHAVIOUR OF ANY PROGRAM TO RUN WITH THE PERMISSION OF
		THE OWNER RATHER THAN WITH THAT OF THE CURRENT USER OF THE PROGRAM
SETTING THE SETUID/SETGID BITS:
	- COMMANDS:
		-- CHMOD U+S SOMEFILE
		-- CHMOD G+S SOMEFILE
		-- CHMOD G+S SOMEDIR --> FILES CREATED IN THIS DIRECTORY ARE GROUP OWNED BY THE GROUP OWNER OF THE DIRECTORY.


<------------------------------------------------------------------------------------------------------------------------>

						CHAPTER 19. LINUX SECURITY MODULES
THE RESPONSIBLITY OF PROTECTING A SYSTEM FALLS ON:
	- APPLICATION DESIGNERS
	- LINUX KERNEL DEVELOPERS AND MAINTAINERS

OBJECTIVES:
	- UNDERSTAND HOW THE LINUX SECURITY MODULES FRAMEWORK WORKS AND HOW IT IS DEPLOYED
	- LIST THE VARIOUS LSM IMPLEMENTATIONA AVAILABLE
	- DELINEATE THE MAIN FEATURES OF SELINUX
	- EXPLAIN THE DIFFERENT MODES AND POLICIES AVAILABLE
	- GRASP THE IMPORTSANCE OF CONTEXTS AND HOW TO GET AND SET THEM
	- KNOW HOW TO USE THE IMPORTANT SELINUX UTILITY PROGRAMS

WHAT ARE LINUX SECURITY MODULES?:
	- USING 'MANDATORY ACCESS CONTROLS' LINUX KERNEL ENSURES A SECURE SYSTEM
	- PROTOCOL FOR IMPLEMENTATION ARE:
		-- MINIMIZE CHANGES TO THE KERNEL
		-- MINIMIZE OVERHEAD ON THE KERNEL
		-- PERMITS FLEXIBILITY AND CHOICE BETWEEN DIFFERENT IMPLEMENTATIONS. EACH OF WHICH IS PRESENTED AS A SELF-CONTAINED LSM (LINUX SECURITY MODULE)
		-- BASIC SCENERIO:
			--- REQUEST TO KERNEL SYSTEM ---> KERNEL INVOKES SECURITY SYSTEM
														|
														|
														|				 YES
														|				  |
														V				  V
									DOES USER HAVE RIGHT TO MAKE REQUEST ---> KERNEL CARRIES OUT REQUEST
														|
														|<----NO
														|
														V
											KERNEL DENIES ACCESS TO USER
LSM CHOICES:
	- CURRENT LSMS ARE:
		-- SELINUX -- SECURITY ENHANCED LINUX
		-- APPARMMOR
		-- SMACK
		-- TOMOYO
SELINUX OVERVIEW:
	- USED TO DETERMINE WHICH PROCESSES CAN ACCESS WHICH:-
	 -- FILES
	 -- DIRECTORIES
	 -- PORTS, AND
	 -- OTHER ITEMS ON THE SYSTEM
	- WORKS WITH THESE CONCEPTUAL QUANTITIES:
		-- CONTEXTS: LABELS TO FILES, PROCESSES, AND PORTS, E.G. USER, ROLE, AND TYPE
		-- RULES: IN TERMS OF CONTEXTS, PROCESSES, FILES, PORTS, USERS
		-- POLICIES: SET OF RULES THAT DESCRIBES WHAT SYSTEM-WIDE CONTROL DECISIONS SHOULD BE MADE BY SELINUX

SELINUX MODES:
	- ENFORCING: ALL SELINUX CODE IS OPERATIVE AND ACCESS IS DENIED ACCORDING TO POLICY. ALL VIOLATIONS ARE AUDITED AND LOGGED.
	- PERMISSIVE: ENABLES SELINUX CODE BUT ONLY AUDITS AND WARNS ABOUT OPERATIONS THAT WOULD BE DENIED IN ENFORCING MODE.
	- DISABLED: COMPLETELY DISABLE SELINUX KERNEL AND APPLICATION CODE LEAVING THE SYSTEM WITHOUT ANY OF ITS PROTECTIONS.
	- MODES ARE SELECTED AND EXPLAINED IN A FILE (USUALLY /ETC/SELINUX/CONFIG) WHOSE LOCATION VARIES BY DISTRIBUTION (IS OFTEN EITHER AT
		 /ETC/SYSCONFIG/SELINUX OR LINKED FROM THERE)
	- UTILITIES USED HERE ARE:
		-- SESTATUS: DISPLAY CURRENT MODE AND POLICY
		-- GETENFORCE
		-- SETENFORCE --> $ SUDO SETENFORCE PERMISSIVE
	- TO COMPLETELY DISABLE MODE USE:
		-- CONFIGURATION FILE, /ETC/SELINUX/CONFIG AND SET SELINUX=DISABLED
		-- KERNEL PARAMETER, ADDING SELINUX=0 TO THE KERNEL PARAMETER LIST WHEN BOOTING

SELINUX POLICIES:
	- USUALLY /ETC/SYSCONFIG/SELINUX IS USED TO SET THE SELINUX POLICY.
	- MULTIPLE POLICIES ARE ALLOWED BUT ONLY ONE CAN BE ACTIVE AT A TIME
	- EACH POLICY IS INSTALLED UNDER /ETC/SELINUX/[SELINUXTYPE]
		-- COMMON POLICIES ARE:
			--- TARGETED: DEFAULT POLICY STATE IN WHICH SELINUX IS MORE RESTRICTED TO TARGETED PROCESSES.
				USER PROCESSES AND INIT PROCESSES ARE NOT TARGETED
			--- MINIMUM: HERE ONLY SELECTED PROCESSES ARE TARGETED
			--- MLS" MULTI-LEVEL SECURITY POLICY IS MUCH MORE RESTRICTIVE. HERE ALL PROCESSES ARE ARE PLACED IN A FINED-GRAINED
				SECURITY DOMAINS WITH PARTICULAR POLICIES

CONTEXT UTILITIES:
	- SELINUX CONTEXTS ARE:
		-- USER
		-- ROLE
		-- TYPE
		-- LEVEL
	- SELINUX AND STANDARD COMMAND LINE TOOLS:
		-- PS, LS, CP, MV, AND MKDIR
SELINUX CONTEXT INHERITANCE AND PRESERVATION:
	- NEWLY CREATED FILES INHERIT THE CONTEXT FROM THEIR PARENT DIRECTORY
	- MOVING OR COPYING FILES, IT IS THE CONTEXT OF THE SOURCE DIRECTORY THAT MAY BE PRESERVED
RESTORECON:
	- RESETS FILE CONTEXTS, BASED ON PARENT DIRECTORY SETTINGS.
	- $ RESTORECON -RV /HOME/PETER
SEMANAGE FCONTEXT:
	- USED TO MANAGE THE DEFAULT CONTEXT FOR A NEWLY CREATED DIRECTORY
		-- MKDIR /VIRTUALHOSTS
		-- LS -Z
		-- SEMANAGE FCONTEXT -A -T HTTPD_SYS_CONTENT_T /VIRTUALHOSTS
		-- LS -Z
		-- EFFECTING THE CHANGE ABOVE:
			--- RESTORECON -RFV /VIRTUALHOSTS
			--- LS -Z
USING SELINUX BOOLEANS:
	- SELINUX POLICY BEHAVIOUR CAN BE CONFIGURED AT RUNTIME WITHOUT REWRITING THE POLICY.
	  USING SELINUX BOOLEANS WHICH ARE POLICY PARAMETERS THAT CAN BE ENABLED AND DISABLED.
	- SUDO SEMANAGE BOOLEN -L (LIST BOOLEANS OF CURRENT POLICY, INCLUDING CURRENT STATE AND SHORT DESCRIPTION)
GETSEBOOL AND SETSEBOOL:
	- GETSEBOOL -A --> PRINTS ONLY THE BOOLEAN NAME AND ITS CURRENT STATUS.
	- SETSEBOOL: CHANGING BOOLEAN STATUS NON-PERSISTENTLY WITH -P IT PERSSISTS
	- EXAMPLES:
		-- GETSEBOOL SSH_CHROOT_RW_HOMEDIR
		-- SUDO SETSEBOOL SSH_CHROOT_RW_HOMEDIR ON
		-- SUDO REBOOT --> REMOVES THE ABOVE CHANGES
		-- SUDO SETSEBOOL -P SSH_CHROOT_RW_HOMEDIR ON --> PERSSISTS CHANGES
TROUBLESHOOTING TOOLS:
	- EXAMPLE:
		-- ECHO 'FILE CREATED AT /ROOT' > ROOTFILE
		-- MV ROOTFILE /VAR/WWW/HTML
		-- WGET -O - LOCALHOST/ROOTFILE
			--- ACCESS DENIED
		-- CHECK ERROR LOG --> $ TAIL /VAR/LOG/MESSGAES
			-- SEALERT -L DSKJK03-KJFKLJ-KKHH-EUYKJ-3455
			-- ON RHEL 7 --> GREP HTTPD /VAR/LOG/AUDIT/AUDIT.LOG | AUDIT2ALLOW -M MYPOL
				--->> AUDIT2ALLOW (GENERATES SELINUX POLICIES) AND AUDIT2WHY (TRANSLATES SELINUX INTO A DESCRIPTION OF WHY THE ACCESS WAS DENIED)
		-- CORRECTING ACCESS ISSUE --> RESTORECON -RV /VAR/WWW/HTML/
		-- WGET -Q -O - LOCALHOST/ROOTFILE
			--->> SUCCESS
APPARMOR:
	- IS AN LSM ALTERNATIVE TO SELINUX
	- USED BY SUSE, UBUNTU AND OTHER DESTROS
	- APPARMOR:
		- PROVIDES MANDATORY ACCESS CONTROL (MAC)
		- ALLOWS ADMINISTRATORS TO ASSOCIATE A SECURITY PROFILE TO A PROGRAM WHICH RESTRICTS ITS CAPABILITIES
		- IS CONSIDERED BY SOME TO BE EASIER THAN SELINUX
		- IS CONSIDERED FILESYSTEM-NEUTRAL(NO SECURITY LABELS REQUIRED)
	- APPARMOR SUPPLEMENTS THE TRADITIONAL UNIX DISCREATIONARY ACCESS CONTROL (DAC) MODEL BY PROVIDING MANDATORY ACCESS CONTROL(MAC)
	- IN APPARMOR: VIOLATIONS OF THE PROFILE ARE LOGGED AND CAN BE TURNED INTO A PROFILE BASED ON THE PROGRAMS TYPICAL BEHAVIOUR.

<-------------------------------------------------------------------------------------------------------------------->

							CHAPTER 20. PROCESSES

 - A PROCESS IS AN EMBODIMENT OF A RUNNING APPLICATION WHICH MAY OR MAY NOT CONSIST OF MUTIPLE THREADS
 - PROCESSES HAVE BOTH ATTRIBUTES AND WELL-DELINEATED PERMISSIONS.
 - THEY MUST IN ONE OF A NUMBER OF ENUMERATED STATES, MOST COMMON BEING 'RUNNING' OR 'SLEEPING'
 - IMPORTANT TO KNOW WHEN A PROCESS IS RUNNING IN THE 'USER MODE' OR 'KERNEL MODE' WITH ELEVATED PRIVILEGES FOR THE LATTER.
 - A NUMBER OF DIFFERENT WAYS EXIST TO CREATE 'CHILD' PROCESSES AND TO SET AND MODIFY THEIR PRIORITIES.

OBJECTIVES:
	- DESCRIBE A PROCESS AND THE RESOURCES ASSOCIATED WITH IT
	- DISTINGUISH BETWEEN PROCESSES, PROGRAMS AND THREADS
	- UNDERSTAND PROCESS ATTRIBUTES, PERMISSIONS AND STATES
	- KNOW THE DIFFERENCE BETWEEN RUNNING IN USER AND KERNEL MODES
	- DESCRIBE 'DAEMON' PROCESSES
	- UNDERSTAND HOW NEW PROCESSES ARE FORKED (CREATED)
	- USE NICE AND RENICE TO SET AND MODIFY PRIORITIES

PROCESSES, PROGRAMS AND THREADS:
	- PROCESS:
		-- THIS IS AN EXECUTING PROGRAM AND ASSOCIATED RESOURCES, INCLUDING ENVIRONMENT, OPEN FILES, SIGNAL HANDLERS
		-- THE SAME PROGRAM MAY BE EXECUTING MORE THAN ONCE SIMULTANEOUSLY AND THUS BE RESPONSIBLE FOR MULTIPLE PROCESSES
		-- BASIC STRUCTURE

					PROGRAM
						|
						|----> STARTS PROCESS
						|
						V
					 PROCESS --> PROCESS ID (GROUP ID)
						|
						V
	|------------------------------------------------------| --> THREAD ID (PROCESS ID)
	|		|		|		|		|		|		|	   |
THREAD	 THREAD	  THREAD  THREAD  THREAD  THREAD  THREAD  THREAD


THE INIT PROCESS:
	- THIS IS THE FIRST USER PROCESS ON THE SYSTEM WITH A PROCESS ID = 1
	- REMAINS TILL SHUTDOWN AND IS THE LAST PROCESS TO TERMINATE AT SHUTDOWN
	- ANCESTRAL PARENT OF ALL OTHER USER PROCESSES
PROCESSES:
	- IS AN INSTANCE OF A PROGRAM IN EXECUTION
	- MAY BE IN A RUNNING STATE, OR SLEEP STATE
	- EACH PROCESS HAS:
		-- PID (PROCESS ID),
		-- PPID (PARENT PROCESS ID),
		-- PGI (PROCESS GROUP ID)
	- ANY PROCESS FROM THE KERNEL HAS A '[]' AROUND THEIR NAMES WHEN '$ PS' IS RUN
	- WHEN A PARENT PROCESS DIES BEFORE A CHILD, THE PPID IS SET TO 1 (INIT), OR TO 2 IN NEWER SYSTEMS USING 'SYSTEMD'
	- WHEN CHILD PROCESS TERMINATES NORMALLY OR ABNORMALLY BEFORE ITS PARENTS WHICH HAS NOT WAITED FOR IT AND EXAMINED ITS EXIT CODE IS
		KNOWN AS A 'ZOMBIE (OR DEFUNCT)' PROCESS
	- THE PARENT 'INIT' PROCESS CHECKS ON ITS ADOPTED CHILD PROCESSES AND LETS THOSE WHO HAVE TERMINATED DIE GRACEFULLY
	- PROCESS ARE CONTROLLED 'SCHEDULING', WHICH IS PREEMPTIVE AND IS ONLY DONE BY THE KERNEL
	- LARGEST PID HAS BEEN LIMITED TO A 16-BIT NUMBER, OR 32768
	- PID_MAX CAN BE ALTERED IN THE /PROC/SYS/KERNEL/PID_MAX
PROCESS ATTRIBUTES:
	- THESE INCLUDES:
		-- THE PROGRAM BEING EXECUTED
		-- CONTEXT (STATE)
		-- PERMISSIONS
		-- ASSOCIATED RESOURCES
	- CONTEXT SWITCHING: IS DONE BY THE KERNEL

CONTROLLING PROCESSES WITH ULIMIT:
	- ULIMIT IS A BUILT IN BASH COMMAND THAT DISPLAY OR RESETS A NUMBER OF RESOURCES LIMITS ASSOCIATED
		WITH PROCESSES RUNNING UNDER A SHELL.
	- RUN $ ULIMIT -A
CONTROLLING PROCESSES WITH ULIMIT(CONT.)
	- THE 'ULIMIT -A' VALUES CAN BE CHANGED TO:
		-- RESTRICT (LIMIT TO A VALUE), OR
		-- EXPAND (INCREASE THE CURRENT LIMIT OR VALUE)
	- KINDS OF LIMIT INCLUDE:
		-- HARD: MAX VALUE CAN'T BE EXCEEDED, SET ONLY BY ROOT USER
		-- SOFT: THE CURRENT LIMITING VALUE WHICH A USER CAN MODIFY BUT CAN'T EXCEED HARD LIMIT
	- SYNTAX:
		-- $ ULIMIT [OPTIONS] [LIMIT]
			--- AS IN: ULIMIT -N 1600
		-- PERMANENTLY CHANGING THIS VALUES TO AFFECT ALL CURRENTLY LOGGED IN SHELLS ONE MUST MODIFY /ETC/SECURITY/LIMITS.CONF, THEN REBOOT

PROCESS PERMISSION AND SETUID:
	- PROCESS PERMISSIONS ARE BASED ON PROCESS OWNERSHIP OR USER WHO INVOKED IT.
	- TWO TYPES OF PROGRAMS EXISTS:
		-- SETUID PROGRAMS, PROGRAMS MARKED WITH AN S EXECUTE BIT. THESE RUN WITH A DIFFERENT OWNERSHIP FROM THE CURRENT INVOKER
		-- NON-SETUID PROGRAMS, THAT RUN BASED ON THE REAL USER ID
MORE ON PROCESS STATES:
	- RUNNING:
		-- IS EITHER RUNNING OR SITTING IN RUN QUEUES
	- SLEEPING:
		-- WAITING ON A REQUEST (USUALLY I/O) THAT WAS MADE
	- STOPPED:
		-- SUSPENDED PROCESS, USING CTRL-Z OR DEBUGGER
	- ZOMBIE:
		-- ENTERS THE STATE WHEN IT TERMINATES AND NO OTHER PROCESS (USUALLY PARENT) HAS INQUIRED ABOUT IT STATE.
		-- HERE ALL RESOURCES ARE RELEASED EXCEPT ITS EXIT STATE AND ITS ENTRY IN THE PROCESS TABLE
		-- IT IS ADOPTED BY THE INIT (PID=1) OR KTHREADD (PID=2) WHEN ITS PARENT PROCESS DIES.
EXECUTION MODES:
	- ANY ONE PROCESS CAN BE IN EITHER:
		-- USER MODE
		-- SYSTEM MODE
	- MODES ARE ENFORCED AT HARDWARE LEVEL NOT SOFTWARE LEVEL
USER MODE:
	- ALL PROCESS ARE STARTED IN THE USE MODE BY DEFAULT
	- ALL PROCESSES ARE ISOLALED IN THEIR OWN ENVIRONMENT CALLED PROCESS RESOURCE ISOLATION
	- SYSTEM MODE PROCESSES RUN IN USER MODE UNLESS THEY ARE JUMPING  INTO A SYSTEM CALLED
KERNEL MODE:
	- HERE CPU HAS ACCESS TO ALL HARDWARE ON THE SYSTEM.
DAEMONS:
	- THIS IS A BACKGROUND PROCESS WHOSE SOLE PURPOSE IS TO PROVIDE SOME SPECIFIC SERVICE TO USERS OF THE SYSTEM
	- BASICS OF DAEMONS:
		-- DAEMONS CAN BE QUITE S=EFFICIENT BECAUSE THEY ARE ONLY CALLED WHEN NEEDED
		-- MANY DAEMONS ARE STARTED AT BOOT TIME
		-- DAEMONS NAMES USUALLY END WITH D
		-- SOME EXAMPLES ARE: HTTPD, UDEVD
		-- DAEMONS MAY RESPOND TO EXTERNAL EVENTS (UDEVD), OR ELAPSED TIME (CROND)
		-- DAEMONS GENERALLY HAVE NO CONTROLLING TERMINAL AND NO STANDARD INPUT/OUTPUT DEVICES
		-- DAEMONS SOMETIMES PROVIDE BETTER SECURITY CONTROL
KERNEL-CREATED PROCESSES:
	- THE KERNEL DIRECTLY CREATES TWO KINDS OF PROCESSES:
		-- INTERNAL KERNEL PROCESSES:
			--- TAKE CARE OF MAINTANANCE WORK
			--- THESES OFTEN RUN AS LONG AS THE SYSTEM RUNS
		-- EXTERNAL USER PROCESSES:
			--- RUN IN USER SPACE LIKE NORMAL APPLICATIONS BUT WHERE STARTED BY THE KERNEL
			--- THEY ARE FEW AND SHORT LIVED
		-- TO SEE THESE:
			--- $ PS -ELF
PROCESS CREATING AND FORKING:
	- STEPS:								   THREAD 2
						    CLIENT REQUEST	  /
							  CHILD PROCESS --
							   /              \
							  /                THREAD 1
			                WEBSERVER        /
		                   -- PARENT PROCESS --->
							 \
							  \               THREAD 1
							   \              /
							  CHILD PROCESS --
							CLIENT REQUEST    \
											  THREAD 2

CREATING PROCESSES IN A COMMAND SHELL:
	- STEPS:
		-- USER EXECUTES A COMMAND AT THE COMMAND SHELL:
			---> A NEW PROCESS IS CREATED (FORKED)
			---> A WAIT CALL PUTS THE PARENT TO SLEEP.
			---> THE COMMAND IS LOADED ONTO THE CHILD'S PROCESS SPACE VIS THE EXEC SYSTEM CALL.
			---> THE COMMAND CONPLETES EXECUTING, AND THE CHILD PROCESS DIES VIS THE EXIT SYSTEM CALL
			---> THE PARENT SHELL IS RE-AWAKENDED BY THE DEATH OF THE CHILD PROCESS AND PROCEEDS TO ISSUE A NEW SHELL COMMAND.
			-->> WITH '&' THE PARENT SHELL SHELL SKIPS THE WAIT REQUEST AND IS FREE TO ISSUE A NEW COMMAND IMMEDIATELY
			-->> EXCEPTIONS ARE THE 'ECHO' AND 'KILL' WHICH ARE BUILT INTO THE SHELL AND NO PROGRAM FILES ARE LOADED FOR THEM TO RUN.
USING NICE TO SET PRIORITIES:
	- PROCESS PRIORITIES ARE CONTROLLED USING THE NICE AND RENICE COMMANDS.
	- SCALE (LEAST NICE, HIGHEST PRIORITY)-20 TO +19(MOST NICE, LOWEST PRIORITY)
	- SYNTAX:
		-- NICE -N 5 COMMAND [ARGS]
		-- NICE -5 COMMAND [ARGS]
MODOFIEDDIFYING THE NICE VALUE:
	- ONLY THE SUPERUSER CAN RUN NICE OR RENICE
	- EDITING THE /ETC/SECURITY/LIMIT.CONF
		-- RENICE +3 13848
		-- MAN RENICE FOR MORE INFO
STATIC AND SHARED LIBRARIES:
	- PROGRAMS ARE BUILT USING LIBRARIES OF CODE.
	- STATIC:
		-- THE CODE FOR THE LIBRARIES FUNCTIONS ARE INSERTED INTO THE PROGRAM AT COMPILE TIME AND
			DOES NOT CHANGE THEREAFTER EVEN IF THE LIBRARY IS UPDATED
	- SHARED:
		-- CODE IS LOADED AT RUN TIME AND IF UPDATED THE PROGRAM WILL USE THE NEW LIBRARY.
		-- ADVANTAGES:
			-- SHARED BY APPLICATIONS
			-- BETTER MEMORY USEAGE
			-- SMALLER MORE MANAGEABLE EXECUTABLE SIZES
			-- CALLED DLL (DYNAMIC LINK LIBRARY)
SHARED LIBRARY VERSIONS:
	- NAME CONVENTION: SHAREDLIB.SO.N --> WHERE N = VERSION NUMBER
FINDING SHARED LIBRARIES:
	- LDD: USED TO ACCERTAIN WHAT SHARED LIBRARIES AN EXECUTABLE REQUIRES.
	- $ LDD /USR/BIN/VI
	- LDCONFIG:
		-- USUALLY RUN AT BOOT TIME BUT CCAN BE RUN ANYTIME AND USES THE /ETC/LD.SO.CONF
		-- SHARED LIBS SHOULD ONLY BE STORED IN SYSTEM DIRECTORIES




<----------------------------------------------------CHAPTER 21-------------------------------------------->
SIGNALS

WHAT ARE SIGNALS?
     SENDING SIGNALS TAKES THREE FORMS:
     	     - KILL, KILLALL, PKILL
     PATHS TAKEN BY A SIGNAL:
     	   - FROM KERNEL TO A USER PROCESS AS A RESULT OF PROGRAMMING ERROR.
	   - FROM USER PROCESS (USING A SYSTEM CALL) TO THE KERNEL WHICH WILL THEN SEBD IT TO A USER PROCESS.
	   NOTE: SIGNALS CAN ONLY BE SENT BETWEEN PROCESSES OWNED BY SAME USER OR FROM SUPERUSER TO ANY PROCESS
	   SIGKILL AND SIGSTOP CANNOT BE HANDLED AND WILL ALWAYS TERMINATE THE PROGRAM.

     TYPES OF SIGNALS:
     	   SIGNALS ARE USED TO HANDLE TWO THINGS:-
	   	   - EXCEPTIONS DETECTED BY HARDWARE
		   - EXCEPTIONS GENERATED BY THE ENVIRONMENT
	   $ KILL -L:
	     SHOWS LIST OF SIGNALS
             USE: $ KILL 1991, $ KILL -9 1991, $ KILL -SIGKILL 1991

 KILLALL AND PKILL:
 	 KILLALL - KILLS ALL PROCESSES
 	 	 USE: $ KILLALL BASH, KILLALL -9 BASH, KILLALL -SIGKILL BASH
 	 PKILL - SENDA A SIGNAL TO A PROCESS USING SELECTION CRITERIA
	       USES: $ PKILL [-SIGNAL] [OPTIONS] [PATTERN]
	       	     $ PKILL -U LIBBY FOOBAR

<---------------------------------------CHAPTER 22----------------------------------------------------------->

SYSTEM MONITORING

SYSTEM MONITORING TOOLS INCLUDE: TOP, PS, AND SAR. THESE ACCESS THE PSEUDO-FILE SYSTEM /PROC, AND /SYS

AVAILABLE MONITORING TOOLS:
	  PROCESS AND LOAD MONITORING UTILITIES:-
	  	  TOP        PROCESS ACTIVITY, DYNAMICALLY UPDATED
		  UPTIME     HOW LONG THE SYSTEM IS RUNNING AND THE AVERAGE LOAD
		  PS 	     DETAILED INFORMATION ABOUT PROCESSES
		  PSTREE     A TREE OF PROCESSES AND THEIR CONNECTIONS
		  MPSTAT     MULTIPLE PROCESSOR USAGE
		  IOSTAT     CPU UTILIZATION AND I/O STATISTICS
		  SAR	     DISPLAY AND COLLECT INFORMATION ABOUT SYSTEM ACTIVITY
          numstat    Information about NUMA (Non-Uniform Memory Architecture)
          strace     Information about all system calls a process makes

      Memory Monitoring Utilities:-
          free        Brief summary of memory usage
          vmstat      Detailed virtual memory statistics and block I/O,
dynamically update
          pmap        Process memory map

      I/O Monitoring Utilities:-
          iostat    same as above
          sar       same as above
          vmstat    same as above


      Network Monitoring Utilities:-
          netstat       Detailed networking statistics
          iptraf        Gather information on network interface
          tcpdump       Detailed analysis of network packets and traffic
          wireshare     Detialed network traffic analysis
/proc Basics:
    All important processes have a subdirectory in /proc
    $ ls -F /proc
    $ ls -lF /proc/16477
    $ cat /proc/16477/status

/proc/sys:
    Most tunenable system can be found in this directory
    steps:
        $ ls -l /proc/sys/kernel/threads-max
        $ cat /proc/sys/kernel/threads-max

        sudo bash -c 'echo 100000 > /proc/sys/kernel/threads-max'
        OR
        sudo sysctl kernel.threads-max=100000

/sys Basics:
    Conceptually it is part of the Unified Device Model

sar:
    Systems Activity Reporter
    -gathers system activity and performance data and creating reports that
are readable by humans.

<----------------------------------------------------Chapter 23---------------------------------------------------------->

Process Monitoring

The major tool for doing this are the 'ps' and 'top' programs


Objectives:

	- use ps to view characteristics and statistics associated with processes
	- identify diff ps output fields and customize the ps output
	- use pstree to get a visual descriotion of the processes ancestry and multi-threaded applications
	- use top to view system loads interactively

Monitoring:
	utilities:-
		top - process activity, dynamically
		uptime - hw long the ayatem is running and average load
		ps - detailed information about processes
		pstree - tree of processes and their connections
		mpstat - multiple processor usage

Viewing Processes States with ps:
	ps get its information from the /proc directory
	versions include:
		 - UNIX with options preceded by '-'
		 - BSD   "      "       "      " '-'
		 - GNU   "      "	"      " '--'


BSD Option Format for ps:
    usage: ps aux
    USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    -- meaning:
       VSZ -> virtual memory size in KB
       RSS -> resident set size; the non-swapped physical memory a task is using in KB
       STAT -> state of the process
       	    -- S -- sleeping
	    -- < high priority(not nice)
	    -- N for low priority (nice)
	    -- L for having pages locked in memory
	    -- s for session header
	    -- l for multi-threaded
	    -- + for being in the foreground process group

     -- adding f option shows how processes connect by ancestry $ ps auxf


UNIX Option Format for ps:
     $ ps -elf
     F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
     Common selectio options for UNIX:
     	    -A or -e: select all processes
	    -N: Negate selection
	    -C: Select by command name.
	    -G: Select by real group ID (also supports names)
	    -U: Select by real user ID (also supports names)



Customizing the ps Output:
	    output options:
	    	   - pid: process id number
		   - uid: user id number of process owner
		   - cmd: command with all arguments
		   - cputime: cumulative CPU time
		   - pmem: memory ratio between process and physical memory
	    $ ps -o pid,uid,command
	    for more options do $ ps help


Using pstree:
      $ pstree -aAp 2408
      another method to see children of a process:
      	      $ ls -l /proc/1377/task

Viewing System Loads with top:
	$ top

<----------------------------------------------Chpter 24------------------------------------------------------>
						      I/O Monitoring and Tunning

Two main tools for use in identifying and isolating problems are:
    iostat and iotop
    ionice is used to prioritize the competeion between processes as well


Learning Objectives:
	- use iostat to monitor I/O device activity
	- use iotop to display a constantly updated table of current i/O usage
	- ionice to set both the I/O scheduling class and priority for a given process


Disk Bottlenecks:
     - could be caused by slow I/O


iostat:
	$ iostat
					Result:

	Linux 4.4.0-43-generic (george-HP-Pavilion-17-Notebook-PC) 	16/10/2016 	_x86_64_	(4 CPU)

	avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          	  44.13    0.01    8.95    1.82    0.00   45.11

	Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
	sda              12.74       150.85       120.73    3886066    3110181
	scd1              0.00         0.00         0.00         84          0

	Meaning: tps -> transactions per sec

iostat Options:
       $ iostat -k --> in kB
       $ iostat -m --> in MB
       $ iostat -N --> show device name
       $ iostat -d --> device
       $ iostat -xk --> -x for extended
       Extended:
		Linux 4.4.0-43-generic (george-HP-Pavilion-17-Notebook-PC) 	16/10/2016 	_x86_64_	(4 CPU)

		avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          		  45.65    0.01    9.03    1.70    0.00   43.62

		Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
		sda               1.63    14.94    7.31    5.00   143.87   122.84    43.31     0.30   24.26   20.35   29.97   3.66   4.51
		scd1              0.00     0.00    0.00    0.00     0.00     0.00     8.84     0.00    1.05    1.05    0.00   1.05   0.00




iotop:
	Note: must be runas root
	$ sudo iotop
	  - be --> best effort
	  - rt --> real time
	- $ iotop -o --> can be used to avoid cluttered result


Using ionice to Set I/O Priorities:
      - let you set both the I/O scheduling class and priority for a given process
      - $ ionice [-c class] [-n priority] [-p pid] [COMMAND [ARGS]]



<-------------------------------------------------------Chpt 25----------------------------------------------------------->

                                        I/O Scheduling

System performance often depends very heavily on optimizing the I/O scheduling strategy.

Objectives:

  - explain the importance of I/O scheduling and descibe the conflicting requirements that needs to be satisfied
  - delineate and constrast the options available under linux
  - understand how the CFQ (Completely Fair Queue) and Deadline algorithms works.

I/O Scheduling:

  VM (Virtual Machine) & VFS (Virtual File System)

                    |
                    |
                    V
        I/O Scheduling Layer --> prioritize and order requests
                      |
                      |
                      V
                 Block Devices


I/O Scheduler Choices:

  - CFQ, DEadline, noop

I/O Scheduling and SSD Devices:

  determining if a device is SSD: $ cat /sys/block/<device>/queue/rotational
  - this does not require an elevator scheduling scheme.


<-------------------------------------------------chpter 26------------------------------------->
                                  Memory: Monitoring Usage and Tuning

Objectives:
  - list the primary (inter-related) considerations and tasks invovled in memory tuing
  - know how to use entries in /proc/sys/vm, and /proc/meminfo
  - use vmstat to display information about memory, paging and selects which and processes' memory consumption.
  - understand how the OOM-killer decides when to take action and selects which processes should be exterminated to open some memory.


Memory Tuning Considerations:

Memory MOnitoring Tools:
  Utility         | Purpose                                                     |  Package
  free            | Brief Summary of memory usage                               | procps
  vmstat          | Detailed viryual statics and block I/O, dynamically updatad | procps
  pmap            | Process memory map                                          | procps

/proc/sys/vm:

vmstat:
  vmstat [options] [delay] [count]

  vmstat 2 4
  vmstat -a 2 4 => active and inactive devices
  vmstat -s => memory statistics and certain event counters
  vmastat -d => disk statistics
  vmstat -p /dev/sda1 2 4 =>disk statistics on only one partition

/proc/meminfo:
  cat /proc/meminfo

OOM Killer:
  Out Of Memory Killer (OOM Killer)
  This determines which process gets killes or terminated during insufficient memoey:
    - oom_score


<-----------------------------------------------Chapter 27-------------------------------------------->
                                  Package Management Systems

Objectives:
  - explain s=why software packages management systems should be used
  - understand the role of both binary and source packages
  - list the main available packages management systems
  - understand who two levels of utilities are needed; one that deals with just bare packages, and one that deals with
    dependencies among packages
  - explain how creating your own packages enhances the control you have over exactly what goes in software and how it is installws
  - understand the role of source control systems and git in particular


  Software Packaging Concepts:


  Why Use Packages:
    - automation
    - scalability
    - repeatability
    - security and auditing

  Package Types:
    - Binary --> platform dependent
    - Source --> one used for many platforms, produces binary files
    - Architecture-independent --> run under scripts interpreters, documentation and configuration files
    - Meta-packages --> groups of associated packages that collectively hold everything needed to install a large subsystem

  Available Package Management Systems:
    - RPM --> Red Hat Package Manager
    - dpkg --> debian package

  Packaging Tool Levels and Varieties:
    - Low level Utility:
      -- dependencies are not fully handled
      -- installation, varification, upgrade, removal
      -- rpm dpkg
    - High Level Utility:
      -- dependcies handled
      -- e.g. rpm, apt-get apt-cache, yum, zypper

  Package Sources:
    - maintained by the distributors

<--------------------------------------------Chapter 28--------------------------------------->
                                        RPM
Objectivees:
  - understand how the RPM system is organized and what major operations the rpm program can accomplish
  - explain the naming conventions used for both binary and source rpm files.
  - know how to query, verify, install, uninstall, upgrade and freshen packages.
  - grasp why new kernels should be installed rather than upgrade
  - know how to use 'rpm2cpio' to copy package files into a cpio archive, as well as extract the files without installing them


RPM:
  Redhat Package Manager -
    -- has the following information:
      > how and where to install
      > how and where to uninstall
      > dependencies information - Note: unless a URL is supplied it installs from only local machine using absolute or relative paths
      > distribution dependent - installing on only target machines or OSs

Advatages of Using RPM:
> For system admins:
  - determine what packages (if any) any file on the system is part of
  - determine what version is installed
  - install and uninstall without leaving debris behind
  - determine if a package was installed corectly
  - distinguish documentation files from package files and determine if to install the fomer
  - use ftp or HTTP to install packages over the internet
> For developers:
  - source packagecan be used to build on more than one OS
  - more than one architecture can be used to build from one source package

Package FIle Names:
  - binary naming standard:
    -- <name>-<version>-<release>.<distro>.<architecture>.rpm
        sed-4.2.1-10.el6.x86_64.rpm
    -- <name>-<version>-<release>.<distro>.src.rpm
        sed-4.2.1-10.el6.x86_64.src.rpm

Database Directory:
  - default location is '/var/lib/rpm'
  - '--dbpath' is used to specify a different path
  - '--rebuilddb' option to rebuild the database indeices

Helper Programs and Modifying Settings:
  - location '/usr/lib/rpm'
  - to list helper lib: '$ ls /usr/lib/rpm | wc - l'
  - you can use a 'rpmrc' to specify default settings for 'rpm'
  - 'rpm'  search locations include:
    -- /usr/lib/rpm/rpmrc, /etc/rpmrc, ~/.rpmrc
  - alternative rpmrc file can be specified using the --rcfile option

Queries:
  - $ rpm -q bash - version installed
  - $ rpm -qf /bin/bash - package file came from
  - $ rpm -ql bas - files installed by this package
  - $ rpm -qi bash - information about this package
  - $ rpm -qip foo-1.0.0.1.noarch.rpm - information form package file not data base
  - $ rpm -qa - list all install packages on this system
  - $ rpm -qp --requires foo-1.0.0.1.noarch.rpm - list of prerequisites for package
  - $ rpm -q --whatprovides libc.so.6 - show what installed package provides a particular requisite package

Verifying Packages:
  - $ rpm -Va
  - S -- file size differs
  - M -- file permission or type differs
  - 5 MD5 checksum differs
  - D - device major/minor number mismatch
  - L - symbolic link path mismatch
  - U - user ownership differs
  - G - grp ownership differs
  - T - modification time differs
  - P - capabilities differs

Installing Packages:
  - $ sudo rpm -ivh foo.1.0.0.1.noarch.rpm
  - checks performed at install:
    -- performs dependencies check
    -- conflicts check
    -- runs commands needed before installation
    -- manages configuration files
    -- unpacks files from packages
    -- runs commands needed after installation
    -- updates the system RPM database

Uninstalling pacakges:
  - $ sudo rpm -e system-config-lvm [ will fail if package is not there or is required by other packages]
  - testing for potential failure:
    -- $ sudo rpm -e --test -vv xz

Upgrading Packages:
  - $ sudo rpm -Uvh bash-4.2.45-5.el7_0.4.x86_64.rpm
  - Downgrade:
    -- sudo rpm -Uvh --oldpackage bash-4.2.45-5.el7_0.4.x86_64.rpm

Freshening Packages:
  - $ sudo rpm -Fvh *.rpm

Upgrading the Kernel:
  - Never do a kernel upgrade rather do an install:
    -- $ sudo rpm -ivh kernel-{version}.{arch}.rpm

Using rpm2cpio:
  - extracting a package without installing it:
    -- create cpio:
      --- $ rpm2cpio foobar.rpm > foobar.cpio
    -- list files in an rpm:
      --- $ rpm2cpio foobar.rpm | cpio -t or rpm -qilp foobar.rpm
    -- extract onto the system:
      --- $ rpm2cpio bash-4.2.45-5.el7_0.4.x86_64.rpm | cpio -ivd bin/bash
      --- $ rpm2cpio foobar.rpm | cpio --extract --make-directories


<------------------------------------------- Chapter 29 DPKG ---------------------------------------->
                        Debian Package Manager

Objectives:
  - uses
  - naming convention
  - know what sources packages look like
  - use querying and verifying operations on packages
  - install, upgrade, and uninstall Debian packages

DPKG Essentials:
  - extensions '.deb'
  - folder: /var/lib/dpkg

Package File Names:
  - <name>_<version>-<revision_number>_<architecture>.deb
    -- logrotate_3.8.7-1_amd64.deb
    -- logrotate_3.8.7-1ubuntu_amd64.deb

Source Packages:
  - 3 files found there are:
    -- upstream tarball, ending .tar.gz
    -- description file, ending .dsc
    -- contains patches, .debian.tar.gz or .diff.gz
  - apt-get source logrotate
  - ls -lR logrotate*

DPKG Queries:
  - $ dpkg -l - list all packages
  - $ dpkg -L wget - list files installed in the 'wget'
  - $ dpkg -p wget - show info about 'wget'
  - $ dpkg -I wefs_1.21_ds1-8_amd64.deb - show info about package
  - $ dpkg -c wefs_1.21_ds1-8_amd64.deb - list files in a package file
  - $ dpkg -S /etc/init/networking.conf - show what packages owns
  - $ dpkg -s wget - show status of package
  - $ dpkg -V package - verify

Installing and Upgrading and Uninstalling Packages:
  - $ sudo dpkg -i foobar.deb
  - $ sudo dpkg -r package
  - $ sudo dpkg -p package


<---------------------------------------- Chapter 30 ------------------------------------------------->
                                YUM
Objectives:
  - high level program that uses 'rpm' but is able to resolve dependencies suing remote repos
  - structure:    rpm --> yum --> OS user

What is yum?
  - $ yum cleam [packages | metadata | expire-date | rpmdb | plugins | all ] - removes yum cached information

Configuring yum to Use Repositories:
  - $ ls -l /etc/yum.repos.d - shows list of repos configured with 'yum'

Repository Files:
  - Simple repo:
    -- [repo-name]
        name=Description of the repository
        baseurl=http://somesystem.com/path/to/repo
        enabled=1
        gpgcheck=1

    -- toggle repo on or off using:
      --- --disablerepo=somerepo and --enablerepo=somerepo when using 'yum'

Queries:
  - $ sudo yum search keyword - information about package
  - $ sudo yum list "*keyword*" - what is installed and what else is available
  - $ sudo yum info package
  - $ sudo yum list [installed | updates | available ]
  - $ sudo yum grouplist [group1] [group2]
  - $ sudo yum groupinfo [group1] [group2]

  - $ sudo yum provides "/logrotate.conf" - show packages that conatain file name

Verifying Packages:
  - package verification requires the installation of the 'yum-plugin-verify'
  - $ sudo yum verify [package]
  - $ sudo yum verify-rpm [package]
  - $ sudo yum verify-all [package]


Installing/Removing/Upgrading Packages:
  - sudo yum install package2 [package2]
  - sudo yum localinstall package-file
  - sudo yum groupinstall group-name or sudo yum install @group-name
  - sudo yum remove package1 [package2]
  - sudo yum update [package]

Additinal Commands:
  - sudo yum list "yum-plugin" -- install to use more yum commands
    - sudo yum repolist
    - sudo yum shell [text-file]
  - sudo yum install --downloadonly package for commands below to work
    - sudo yumdownloader pacakge
  - sudo yum history


<------------------------------------------------------ Chapter 31 --------------------------------------------------------------->

Objectives:
  - explain what zypper is
  - discuss the queries zypper can be used for
  - install. remove and upgrade packages using zypper

What is zypper?
  - command line tool for installing and managingg packages in SUSE Linux and openSUSE
  - similar to 'yum' and 'apt-get'

Zypper Queries:
 *Zypper is similar to 'yum' queries
  - $ zypper list-upgrades
  - $ zypper repos - list available repos
  - $ zypper search <string>

Installing/Removing/Upgrading:
  - install or update -- $ sudo zypper install package
  - No confirmation when installing -- $ sudo zypper --non-interactive install <package>
  - update installed packages -- sudo zypper update
  - Non-interactive -- $ sudo zypper --non-interactive update
  - remove a package -- $ sudo zypper remove <package>

Additional zypper Commands:
  - When zypper commands must be run in a sequence -- $ sudo zypper shell

  - add a repo -- $ sudo zypper addrepo URI alias
  - remove a repo from the list -- $ sudo zypper removerepo alias
  - find which package provides a file -- $ sudo zypper waht-provides <file-path>


<------------------------------------------------- Chapter 32 ------------------------------------------->
                                                    APT
Advanced Packaging Tool -
  - main utilities are 'apt-cache' and 'apt-get'

Objectives:
  - explain APT
  - user apt-cache
  - install, remove, and upgrade packages using 'apt-get'

What is APT:
  - advanced packaging tool laid on top of 'debian dpkg'

apt-get:
  - install, manage and update

Queries Using apt-cache:
  - $ apt-cache search apache2
  - $ apt-cache show apache2 -- show basic information
  - $ apt-cache showpkg apache2 -- show detailed information
  - $ apt-cache depends apache2 -- show dependent packages
  - $ apt-file search apache2.conf --search the repo for a file named apache2.conf
  - $ apt-file list apache -- list all files in the apache2
  - $ apt-file find <file path> -- used to find which package provides the file specified

Installing/Removing/Upgrading:
  - available package list on debian -- /etc/apt/aources.list
  - sudo apt-get update
  - sudo apt-get install [package]
  - sudo apt-get remove [package]
  - sudo apt-get --purge remove [package] -- remove with config file
  - sudo apt-get upgrade - upgrade all installed packages
  - sudo apt-get dist-upgrade -- smart upgrade
  - sudo apt-get autoremove -- remove unneeded packages
  - sudo apt-get clean -- clean out cached files

<---------------------------------------------- Chapter 33 ------------------------------------------->
                                        User Account Management

Objectives:
  - explain the purpose of individual user accounts and list its main attributes
  - create, modify, remove, and lock accounts
  - understand how user passwords are set, encrypted and stored, how to require changes in password over time due to security
  - explain how restricted shells and restricted accounts work
  - understand the role of root account and when to use it

User Accounts:
  - purposes include:
    -- provide each user with their own individualized private space
    -- for specific dedicated purposes
    -- distinguisheing privileges among users
    -- Note: the 'daemon' account exists to allow processes run as a user other than root

Attributes of User Account:
  - The seven elements are:
    -- user name
    -- user password
    -- user identification number (UID)
    -- group identification number (GID)
    -- comment or GECOS --> information on the user
    -- Home directory
    -- Login shell

Creating User Accounts with useradd:
  - $ sudo useradd koko
    -- steps:
        -> next available UID greater than UID_MIN (as specified in /etc/login.defs) is assigned as koko's UID
        -> group called 'koko' with GUI=UID is also created as koko's default group
        -> home directory /home/koko is created
        -> koko's login shell will /bin/bash
        -> contents of 'etc/skel' is copied to '/home/koko'
        -> an entry of !! or ! is placed in the password filed of the ''/etc/shadow' file for koko's entry thus requiring the admin to assign a password for account to be useable
    -- defaults can also be overruled:
      - $ sudo useradd -s /bin/bash -m -k /ec/skel -c "Bullwinkle J Marxh" bmoose

Modifying and Deleting User Accounts:
  - $ sudo userdel isable -- all refrences to user in '/etc/passwd', '/etc/shadow' and '/etc/group'
  - $ sudo userdel -r isabel -- will also remove '/home/isabel' leaving files owned by user on system
  - Change the xteristices of a user using, '$ sudo usermod' for options see '$ sudo usermod --help'

Locked Accounts:
  - locked account means user or programs cannot login into system
  - means of keeping a user out includes:
    -- $ sudo usermod -L koko --> 'unlock' $ sudo usermod -U
    -- $ sudo chage -E 2014-09-11 koko -> change expiration date
    -- edit '/etc/shadow' and add 'any invalid string'

User IDs and /etc/password:
  - always use 'usermod or vipw' to edit or change values in '/etc/passwd, /etc/group, /etc/shadow'

/etc/shadow:
  - fields here include:
    -- username
    -- password
    -- lastchange
    -- mindays -> min days before which password must be changed
    -- maxdays -> days after when password must be changed
    -- warn -> before passwrd expires
    -- grace -> days after passwd expire that account is disabled
    -- expire -> date account will be disabled
    -- reserved -> reserved field
Password Management:
  - user changing own password -> $ passwd
  - root changing user password -> $ sudo passwd koko

Chage: Password Aging
  - used to setup password xteristics
  - chage [-m mindays] [-M maxdays] [-d lastday] [-I inactive] [-E expiredate] [-W warndays]
  - user can only use 'chage' to see their aging: $ sudo chage -l coop
  - forcing user to change password at next login: $ sudo chage -d 0 USERNAME

Restricted shell:
  - Under Linux this is used to restrict the user: '$ /bin/bash -r'
     --

Restricted Accounts:
  - helps to:
    -- uses the restricted shell
    -- limits available system programs and user applications
    -- limits system resources
    -- limits access times
    -- limits access locations
  - to create it:
    - cd /bin ; sudo ln -s bash rbash
    - cd /bin ; sudo ln bash rbash
    - cd /bin ; sudo cp bash rbash
       -- then use /bin/rbash in the /etc/passwd

The root Account:
   - Root login is permitted only from the devices listed in '/etc/security'

SSH:
  - steps to login via ssh:
    -- whoami
    -- $ ssh aomesite.com
    -- as another user:
      -- $ ssh root@somesite.com or $ ssh -l root somesite.com
    -- copy files:
      --> $ scp file.txt somesite.com:/tmp
      --> $ scp file.txt student@somesite.com/gome/student
      --> $ scp -r some>dir somesite.com:/tmp/some_dir
    -- on multiple machines:
      -- $for macines in node1 node2 node3
         do (ssh $machine some_command &)
         done

ssh Configuration Files:
  - user configurations are stored in the .ssh directory
  - ls -l ~/.ssh
