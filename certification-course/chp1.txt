
<<------------------------------------------------------------------------------------------->>
                               Chapter 1

UEFI - Unified Extensible Firmware Interface
BIOS - Basic Input and Output System

- files in the /etc control startup behaviour especially those in the
  /etc/default and /etc/sysconfg

OBJECTIVES:
   -Explain the boot process
        The basic steps are:
           1. The BIOS/UEFI locates and executes the boot program, or boot loader.
           2. The boot loader loads the kernel.
           3. The kernel starts the 'init' process(pid=1).
           4. init manages system initialization, using conventional 'SysVinit' startup scripts, or
              using 'Upstart' or sysmd.
                                                         Checkmemory and hardware
                                                        /
           STEPS: BIOS ---> Power On Self Test(POST) -->
                                                        \
                                                         Locates boot program in MBR(Master Boot Record)
                                                                                |
                                                                                V
									                                            GRUB(GRand Unified Bootloader)
											                                                          |
							                                                                  V
                                                                             Kernel
                                                                                |
                                                                          Hardware check
                                                                                |
                                                                       init processes start
                                                                               /|\
                                                                              / | \
                                                                     SysVinit   |  systemd
                                                                 init scripts   |
                                                                             Upstart

   -Identify several types of boot loaders.
        Types include:
              GRUB
              LILO - Linux Loader (obsolete)
              efilinux - designed for the UEFI mechanism
              Das U-Boot - most popular loader for embedded Linux systems; others include
                           bareboot.
   -Describe what BIOS does.
        Checks memory and hardware, then locates Boot loader in MBR
   -Identify the relevant configuration files.
        they are: /etc/sysconfig for RHEL, and /etc/default for Debian systems
   -Describe how the system shuts down and reboots.
        commands examples:
             sudo shutdown -h +1 "Power Failure imminent"
             sudo shutdown -h now
             sudo shutdown -r now
             sudo shutdown now
             FORMAT: shutdown [OPTIONS...] [TIME] [WALL...]
             find more help using 'shutdwon --help'

   Basic Steps For Computer Startup:
          1 - Boot loader
          2 - Linux kernel and initrd or initramfs loaded into memory and kernel executes
          3 - init process starts
          4 - Additional kernel modules(including device drivers) are loaded, system services started.


<<------------------------------------------------------------------------------------------------------------>>

                                    Chapter 3

 OBJECTIVES:
      - Explain what the role of the GRUB is.
          1 - handles the early phases of system startup
          2 - makes it possible to choose alternatives OS
          3 - makes it possible to choose alternative kernels and/or initial ramdisks at boot time
          4 - Boot paramters can be easily changed at boot time without having to edit configuration
              files, etc. in advance.
      - Understand the differences btween the GRUB 1 and GRUB 2 versions.
              GRUB 1 :
                 - file read at boot are
                      /boot/grub/grub.cfg or /boot/grub2/grub.cfg
                      This file is auto-generated by update-grub (or grub2-mkconfig on RHEL 7)
                      based on configuration files in the /etc/grub.d directory and on /etc/default/grub
              GRUB 2 :
                 - file read at boot are
                      /boot/grub/grub.conf or /boot/grub/menu.lst.
                      In RHEL 5-7, it can be edited using the 'grubby utility'. Any changes made will be preserved
                      but in GRUB 2 any changes to grub.cfg is lost when next it is auto-generated.
      - Be familiar with the interactive selections you can make at boot.
              - on entering the GRUB environment after BIOS setup menu appears
              - menu offers the ffl.:
                          ~ list of bootable images
                          ~ interactive shell - for altering the available stanzas
                          ~ enter pure shell command
                          ~ reinstall GRUB

      - Know how to install GRUB                                                    GRUB 1 using a program called grub -> $ sudo grub or grub-install
                                                                                   /                                      > root (hd0, 0)
              - install grub program and associated utilities in proper locations -                                       > setup (hd0)
                                                                                   \                                      > exit
                                                                                    \
                                                                                     GRUB 2 uses a bunch of utilities like grub2-* or grub-*
                                                                                        -> $ sudo grub2-install /dev/sda

              - installing files GRUB needs to operate at boot time, either under /boot/grub or /boot/grub2
                           : Linux kernel files vmlinux-*, initramfs-* which need to be in the /boot directory
              - installing GRUB as the boot loader in the system

      - Explain how the configuration files that GRUB needs are used and modified.
                    - the two locations that are used in the reconstruction of the /boot/grub2/grub.cfg are:
                          /etc/default/grub, and
                          /etc/grub.d

-----------------------------------------------------------------------------------------------------------------<<
                   GRUB Device Nomenclature

     - sda1 is (hd0,1) in GRUB 2 but (hd0,0) in GRUB 1
     - sdc4 -s (hd2,4) in GRUB 2 but (hd1,3) in GRUB 1

  Note: In the configuration file, each stanza has to specify what the root partition is i.e. the partition that contains
        the 'kernel' itself(in the /boot directory), say /boot had its own directory /dev/sda1, then
        For GRUB 1,
                title 3.17.3
                       root (hd0,0)
                       kernel vmlinuz-3.17.3 ro root=/dev/sda2 quiet
                       intrd intramfs-3.17.1.img

        If /boot is not in its own partition, it might look like
                  title 3.17.3
                        root (hd0,0)
                        kernel /boot/vmlinuz-3.17.3 ro root=/dev/sda1 quiet
                        intrd /boot/intramfs-3.17.3.img

       it is also fine to do kernel (hd0,0)/vmlinuz

<<------------------------------------------------------------------------------------------------------------------------>>

                                      Chapter 4 init: SystemV, Upstart, Systemd

Steps:
	Device recognition and initialization
	launch system services
	filesystems made available
	start important management systems
	make system available


OBJECTIVE:
	- Understand the importance of the 'init' process.
	- Explain the traditional init method works and how it incorporates 'runlevels' and
	  what happens in each one.
	- know how to use chkconfig and service to start and stop services or make them persistent across
	  reboots.
	- Understand the alternative 'Upstart' and 'systemd'
	- Use 'systemctl' to configure and control 'systemd'.


The mother process controller is the /sbin/init or simple called 'init'

                                 System Runlevels
     -----------------------------------------------------------------------------
       Runlevel         |         Meaning
     -----------------------------------------------------------------------------
           S,s          |  Same as 1
           0            |  Shutdown system and turn off
           1            |  Single User Mode
           2            |  Multiple user, no NFS, only text login
           3            |  Mutiple user, with NFS and network, only text login
           4            |  Not used
           5            |  Multiple user, with NFS and network, graphical login with X
           6            |  Reboot
     ------------------------------------------------------------------------------


telinit can be used to change from one level to another
$ sudo /sbin/telinit 5

On start the 'init' process reads the /etc/inittab
	- Here the scripts to be run are mentioned along with other parameters.
	- Format: id:runlevel(s):action:process
		- where:
		    id - a unique 1-4 character identification for the entry
		    runlevel(s) - zero or more single characters or digit indicating runlevel the action will be taken for.
		    action - describes the action to be taken.
		    process - specifies the process to be executed.


The 'init' run steps:
                                                  1                    2
	(init)/sbin/init -----> /etc/inittab ===> (script)rc.sysinit ===> (script)rc
	                   |              ^                        ^
	                   |							|                        |
	                   |			[start LVM, mount fs, etc.]      |
	                   |							 |
	    <Reads from for scripts to be run>                     |
	    									 |
	    					<makes system to go to rc.d/rc[0-6].d and run all scrips there>


Note: All runlevel directory link back to the /etc/init.d directory where all the scripts actually reside.
      Start scripts start with S in name
      Kill scripts start with K in name
      --Controlling which initialization scripts are run on entry to each runlevel involves managing the symbolic links,
        this can be done manually but the 'chkconfig' utility is used to do this efficiently.
Note: Ubuntu uses update-rc.d inplace of chkconfig

	chkconfig useage:
		- check service to see if it is set to run in the current level
		'chkconfig service_name'

		- see what services are configured to run in each of the run levels
		'chkconfig --list [service names]

		- Turn on a certain service next time the system boots
		'sudo chconfig somme_service on'

		- Do not turn on a service next time the system boots
		'chkconfig some_service off

		- Change a currently running service
		'sudo chkconfig service_name [stop | start]

The chkconfig utility process explained:
  Syntax in scripts:
     #  chkconfig: 2345 10 90
		--meaning runlevel 2, 3, 4, 5
		--start script -> S10
		--stop script -> K90


UPSTART:
	 is 'event driven', rather than being a set of serial procedures. Event notifications are sent to the 'init' process to tell it to execute
	certain commands at the right time after pre-requisites have been fulfilled. 'Upstart' is being superseded by 'systemd'.

	Upstart configuration files are:
		- /etc/init/rcS.conf
		- /etc/rc-sysinit.conf
		- /etc/inittab
		- /etc/init/rc.conf
		- /etc/rc[0-6].d

	Upstart events are found in the /etc/event.d or (in Ubuntu) /etc/apm/event.d

	Using 'initctl'	you can view, start, stop jobs in much the same way as that 'service' does.
	       syntax: initctl options command
	               - options includes: start, stop, restart, reload, status, list, emit

	      More info: www.//upstart.ubuntu.com/cookbook

UPSTART STEPS:
--------------


             (/sbin/init)
                |
Kernel -----> init
                  \
                   \
                    \
                    V
                    rcS.conf(script)
                    |
                    |
                    |
                    V
                    rc-sysinit.conf(script)
                   /
                  /
                 V
   -LVM loaded
   -Mount filesystems
   -Execute all runlevel
    scripts specified in the
    /etc/inittab via
    the rc.conf script
   -then prefdm.conf is run
    at runlevel 5

SYSTEMD(systemd)
---------------
  features include:
      - compatible with SysVinit scripts.
      - Boosts faster.
      - provides paralization capabilities.
      - Uses socket and D-Bus activation for starting services.
      - Replaces scripts with programs.
      - Offers on-demand starting daemons
      - Keeps track of processes using cgroups(control groups).
      - snapshots capabilities and system state restoration.
      - can be a drop in replacement for SysVinit.
      - uses '.service' files rather than bash scripts
  Examples of new configuration files for systemd are:
      - /etc/hostname (redhat, replaces /etc/sysconfig/network)
      - /etc/HOSTNAME SUSE
      - /etc/hostname Debian
      - /etc/vconsole.conf - default keyboard mapping and console font
      - /etc/sysctl.d/*.conf - drop-in directory for kernel 'sysctl' parameters
      - /etc/os-release - distros ID


     Runlevel    Target Units                          Description
     0           runlevel0.target, poweroff.target     Shut down and power off the system.
     1           runlevel1.target, rescue.target       Set up a rescue shell.
     2           runlevel2.target, multi-user.target   Set up a non-graphical multi-user system.
     3           runlevel3.target, multi-user.target   Set up a non-graphical multi-user system.
     4           runlevel4.target, multi-user.target   Set up a non-graphical multi-user system.
     5           runlevel5.target, graphical.target    Set up a graphical multi-user system.
     6           runlevel6.target, reboot.target       Shut down and reboot the system.

NOTE:--------------------------------------------------------------
      SysVinit                                       systemd
         |                                              |
         v                                              v
   service utility                               systemctl utility
   update-rc.d, invoke-rc.d -- Ubuntu, Debian
   sysv-rc-conf -- Ubuntu
   chkconfig -- RHEL, CentOS, Fedora
   ----------------------------------------------------------------

 'systemctl' is the main utility for managing services in 'systemd'

  Basic syntax: $ systemctl [options] command [name]


  Useage examples:
        $ systemctl --> shows status of systemd controlled services

        $ systemctl list-units -t service --all --> show all available services

        $ systemctl list-units -t service  --> show only active services

        $ sudo systemctl start foo --> start or activate foo  service
          sudo systemctl start foo.service
          sudo systemctl start /path/to/foo.service

        $ sudo systemctl stop foo.service --> stop(deactivate) a service

        $ sudo systemctl enable sshd.service --> to enable or disable a service
          sudo systemctl disable sshd.service
              -- equivalent to chkconfig --add/ --del and doesn't actually start the service.



<---------------------------------------------------------------------------------------------------------------->
                                               Chp 5 Linux Filesystem Tree Layout

Types of file system differ by:
	- purpose
	- size
	- ownership
	- sharing

Objectives of chpter 5:
	- Explain why Linux requires the organization of one big filesystem tree, and
	  what the major considerations are for how it is done.
	- Know the role played by the Filesystem Hierarcchy Standard.
	- Describe what must be available at boot in the root(/) directory, and waht
	  can available only once the system has started.
	- Explain each of the main subdirectory trees in terms of purpose and contents.

File systems are:
1. Shareable vs. non-shareable
2. Variable vs static


File main directories present in FHS

Directory       In FHS?         Purpose
/		             Yes		         Primary directory of the entire file system hierarchy.
/bin		         Yes		         Essential executable programs that must be available in 'single user mode'.
/boot		         Yes		         Files neede to boot - kernel, initrd ot initramfs, images, boot configuration files and bootloader programs.
/dev		         Yes		         Device nodes, used to interact with hardware devices.
/etc		         Yes		         System wide configuration files.
/home		         Yes		         User home directories including personal settings, files, etc.
/lib		         Yes		         Libraries required bt executable binaries in .bin and /sbin.
/lib64		       No		           64-bit libraries requires by executable binaries in /binand /sbin, for systems which can run both 32-bit and 64-bit programs.
/media		      Yes		           Mount points for removable media such as CDs, DVDs, USB sticks etc.
/mnt		        Yes		           Temporarily mounted filesystems.
/opt		        Yes		           Optional application software packages.
/proc		        Yes 		         Virtual pseudo-filesystem giving information about the system and processes running on it
				                          Can be used to alter system parameters.
/sys		         No		           Virtual psuedo-filesystem giving information about the system and processes running on it. Can be used to
				                          alter system parameters. Similar to a device tree and is part of the Unified Device Model.
/root		       Yes		           Home directory of the root user.
/sbin		       Yes		           Essential system binaries.
/srv		       Yes		           Site-specific data served up by the system. Seldom used.
/tmp		       Yes		           Temporary files; on many distributions lost across reboot and may be a ramdisk in memory.
/usr		       Yes		           Multi-user applications, utilities and data; theoretically read-only.
/var		       Yes		            Variable data that changes during system operation.


 The three file associated with each 'bootable kernel' are:
 	- vmlinuz -- compressed Linux kernel
 	- initramfs or initrd -- Initial RAM Filesystem, mounted before the real root filesystem becomes available.
 	- config --configuration file used when compiling the kernel. Used mainly for bookkeeping and reference
 	- System.map -- The kernel 'symbol table', useful for debugging. Gives the 'hexadecimal addresses' of all kernel symbols.

---------------------
/bin
---------------------
	contains executable binaries needed buy both admin and unprivileged users.
	may not contain subdirectories

---------------------
/boot
---------------------
	two main absolutely essential files are: vmlinuz --> comporessed kernels
						 initramfs --> initial RAM Filesystem

---------------------
/dev
---------------------
	contains special device files(also known as device nodes) this represent devices built into or connected to the system.
	network devices do not have device nodes in Linux and are referenced by names such as eth1 or wlan0

---------------------
/etc
---------------------
	contains machine-local configuration files; there should be no executable binary programs.
	sample files and directories include:
		- /etc/sysconfig -- system configuration and directories (Red Hat)
		- /etc/default -- same as above (Debian)
		- /etc/skel -- contains skeleton files used to populate newly created home directories
		- /etc/init.d -- contains start up amd shut down scripts when using System V initialization

--------------------
/home
--------------------
	contains all personal configuration, data, and executable programs.


-------------------
/lib
-------------------
	contains only thise libraries needed to execute the binaries in /bin and /sbin. These are useful for booting the system
	and executing commands within the filesystem.
	kernel modules(device and filesystem drivers) are located under /lib/modules/<kernel-version-number>
	PAM(Pluggable Authentication Modules) files are stored in the /lib/security
	Systems that support both 32-bit and 64-bit libraries use /lib and /lib64 respectively.

-------------------
/media
-------------------
	used to mount filesystems on removeable media such as CDs, DVDs, and USB drives or even old floppy disks
	on SUSE and RHEL 7 removable media will pop up under /run/media/[username]/....

------------------
/mnt
------------------
	used to temporarily mount a filesystem when needed. Like
		- NFS
		- Samba
		- CIFS
		- AFS

-----------------
/opt
-----------------
	used by software packages that wish to keep all their files in one isolated place rather than scatter themall over
	the system.
	Example: dolphy_app -- /opt/dolphy_app/bin, /opt/dolphy_app/man
	Special subdirectories of /opt are:
		/opt/bin

----------------
/proc
----------------
	mount point for a pseudo-filesystem, where information only resides in memory, not on disk. Like /dev the /proc is
	 empty on a non-running system.
	Here each active process on the system has its own subdirectory that gives detailed information about the state of the process,
	 the resources it is using, and its history.
	Important pseudo-files include:
		- /proc/interrupts -------
		- /proc/meminfo          |
		- /proc/mounts           |-------> system's hardware
		- /proc/partitions  ------

		- /proc/filesystem ------|
		- /proc/sys/-------------|-------> system configuration information and interfaces

----------------
/sys
----------------
	mount point for sysfs pseudo-filesystem, where information resides only in memory
	sysfs is used both to gather information about the system, and modify its behaviour while running.


---------------
/root
---------------
	home directory of the root user

--------------
/sbin
--------------
	contains binaries essential for booting, restoring, recovering, and/or repairing
	must be able to mount other filesystems on /usr, /home and other locations
	these programs should be included here:
		- fdisk, fsck, getty, halt, ifconfig, init, mkfs, mkswap, reboot, route, swapon, swapoff, update.
	contains binaries essential for booting, restoring, recovering, and/or repairing in addition to those binaries in /bin.
	they must also be able to mount other filesystems on '/usr, /home' and other locations, once the root system is known to be in good health during boot.
	The following programs shld be included in this directory, if their subsystems are installed:
		fdisk, fsck, getty, halt, ifconfig, init, mkfs, mkswap, reboot, route, swapon, swapoff, update.
	Note: some recent repos are merging /sbin and /usr/sbin as well as /bin and /usr/bin.

-------------
/tmp
-------------
	store temporary files, accessed by any user
	reset /tmp behaviour on RHEL 6 using 'systemctl mask tmp.mount
	for temporary files
	regularly cleaned of its contents at regurlar basis using 'cron jobs' or 'at reboot'
	files here are stored in memory not disk
	Note: canceling the usage of /tmp for creating large files can be done using the command: systemctl mask tmp.mount, then 'reboot'

-------------
/usr
-------------
	secondary hierarchy
	used for files that are not needed for system booting.
	may be located at location different from root directory
	software packages should not create subdirectories directly under /usr
	typically read-only data
	contains binaries which are not needed in single user mode


	Directory       |          Purpose
	---------------------------------------------------------------------------------
	/usr/bin	      | binaries for applications not needed in single user mode
	/usr/include	  | header files for compiling applications
	/usr/lib	      | Libraries for programs in /bin and /sbin.
	/usr/lib64	    | 64-bit libraries for 64-bit programs in /bin and /sbin.
	/usr/sbin	      | Non-essential system binaries, e.g. system daemons.
	/usr/share	    | Shared dara used by applications, architecture-independent
	/usr/src	      | Source files usually for linux kernel.
	/usr/X11R6	    | X Window files; generally obsolete.
	/usr/local	    | Local data and programs specific to the host. Subdirectories include bin, sbin, lib, share, include, etc.


-----------------
/var
----------------
	contains variable (or volatile) data files that change frequently during system operation.
	Examples:
		- Log file
		- Spool directories and files for printing, mail queues, etc.
		- Admin data files
		- Transient and temporary files


		Directory       |         Purpose
		--------------------------------------------------------------------------------
		/var/ftp	      | ftp server base
		/var/lib	      | Persistent data modified by programs as they run.
		/var/lock	      | Lock files used to control simultaneous access to resources.
		/var/log	      | Log files
		/var/mail	      | User mailboxes
		/var/run	      | Information about the running system since the last boot.
		/var/spool	    | Tasks spooled or waiting to be processed, such as print queues.
		/var/tmp	      | Temporary files to be persisted across reboot, at times linked to /tmp
		/var/www	      | Root for website hierarchies.


-----------------
/run
-----------------
	stores transient files: those that contain run-time information, which may need to be written early in system startup.



<------------------------------------------------------------------------------------------------------>

				                                              Chapter 6

This lies at the heart of the Linux operating system.
It controls access to hardware, competition for resources between different applications and other tasks, handles I/O activity and
	files and data storage, security, networking, etc.
Adding kernel command line parameters at boot time, the system can be made to behave in many different ways.

	Learning Objectives:
		- grasp the main responsibilities the kernel must fulfill and how it achieves them.
		- Explain what parameters can be set on the kernel command line and how to make them effective either for just one
		  system boot, or persistently.
		- know where to find detailed documentation on these parameters.
		- know how to use sysctl to set kernel parameters either after the system starts, or persistently across system reboots.


	kernel serves as a connection between hardware and software
	handles all connected devices using 'device drivers'

	Main kernel:
	        - system initialization and  boot up.
	        - process scheduling
	        - memory management
	        - controlling access to hardware
	        - I/O between applications and storage devices.
	        - Implementation of local and network filesystems.
	        - Security control, both locally (such as filesystem permissions) and over the network.
	        - networking control.

Kernel Command Line:
        GRUB version 1
                /boot/grub/grub.conf
        GRUB version 2
                /boot/grub2/grub.cfg

        cat /proc/cmdline -- shows what cmdline a system was booted with.


-Kernel Boot Parameters:
	sources of documentation for kernel parameters includes:-
		- in the kernel source Documentation/kernel-parameters.txt
		- Online, at http://kernel.org/doc/Documentation/kernel-parameters.txt
		- On the as kernel-doc or linux-doc
		- By typing 'man bootparam'

	parameters may be typed as an argument or in the form param=value, where value can be a 'string, integer, array of integers
	etc.

	Bootparameters:
		- ro -- mounts root device read-only on boot.
		- root -- root filesystem
		- rd_LVM_LV -- it activates the root filesystem in the logical volume specified
		- rd_NO_LUKS -- disables crypto LUKS detection.
		- rd_NO_DM -- disables DM RAID detection.
		- LANG -- is the system language.
		- SYSFONT -- is the console font.
		- KEYTABLE -- is the keytable filename.
		- rhgb -- for graphical boot support on Red Hat systems.
		- quiet -- disables most log messages.

	'sysctl' interface can be used to read and tune kernel parameters at run time. To display current values - 'sysctl -a'
		- More details: sysctl use -- man 8 sysctl
				sysctl() use -- man 2 sysctl
		- if settings are in /etc/sysctl.conf -- man sysctl.conf
	Note:
		kernel command line allows specification of start up options
		sysctl allows specification of run time options


<------------------------------------------------------------------------------------------>

                Chapter 7 Kernel Modules

Objectives:
	- list the advantages of utilizing kernel modules.
	- use insmod, rmmod, and modprobe to load and unload kernel modules.
	- know how to use modinfo to find out information about kernel modules.


	Advatages of kernel modules include:
		- it facilitates development
		- kernel reboots are not required
		-


	Module utilities:
		- lsmod -- list modules
		- insmod -- directly load modules
		- rmmod -- directly remove modules
		- modprobe -- load or unload modules, using a pre-built module database with dependency information
		- depmod -- rebuild the module dependency database; needed by modprobe and modinfo
		- modinfo -- display information about a module.
	Syntax for loading and unloading modules
		sudo /sbin/rmmod module_name
		sudo /sbin/insmod <pathto>/module_name

		------------OR using modprobe---------

		sudo /sbin/modprobe module_name
		sudo /sbin/modprobe -r module_name

	information on modules can be gotten using:
		modinfo module_name OR /sbin/modinfo my_module, /sbin/modinfo <pathto>/my_module.ko

		A modules status can be seen in the /sys pseudo-filesystem directory tree
			- e.g.:
				for module e1000
				/sys/module/e1000
				some or if not all parameters can be 'read or written' under /sys/module/e1000/parameters
	Module parameters:loading module with parameters
		sudo /sbin/insmod <pathto>/e1000.ko debug=2 copybreak=256
		sudo /sbin/modprobe e1000 debug=2 copybreak=256
		Note: files in the /etc/modprobe.d control some parameters that come into play when using modprobe

<---------------------------------------------------------------------------------------------------------->

			                  Chapter 8. Devices and UDEV

	Linux uses udev to discover devices (hardware and peripheral) both during boot and later on when connected to the system.
	Device nodes are created automatically and then used by apps and OS subsystems to communicate with and transfer data to and from devices.

	Objectives:
		- Explain the role of 'device nodes and how they use major and minor numbers.
		- Understand the need for the udev method and list its key components.
		- Descibe how the udev device manager functions.
		- Identify udev rule files and learn how to create custom rules.

	Character and block devices have filesystem entries associated with them; network devices in Linux do not.
		These device nodes can be used by programs to communicate with devices, using I/O system calls such as 'open(), close(), read(),
		and write().
	Network devices work by transmitting and recieving packets of data.

	Device nodes can be created with:
		sudo mknod [-m mode] /dev/name <type> <major> <minor>
		e.g., mknod -m 666 /dev/mycdrv c 254 1

					Device Nodes
					------------

	---------------------------------------------------------------------------------
        |		              Application                                       |
	---------------------------------------------------------------------------------
		                                  / \			                    / \
		                                   |                           |
		                                   |                           |
		                                   | 	                         |
		                                   V       		                 |
	-------------------------------------------------------------    |
	|                        Virtual File System                |    |
	-------------------------------------------------------------    |
		     / \                / \           / \                      |
		      |			             |	           |                       |
		      |			             |	           |                       |
		      V			             V	           |                       |
	      -------------------     --------------         |  -----------    |
        |character node   |     |block node  |<--------|  |socket   |    |
        -------------------     -------------             ----------     |
               / \                  / \                       / \        |
                |	                   |                         |         |
                |                    |                         |         |
                V                    V                         V         V
        -------------------     --------------           -----------------
        |character driver |     |file system |           | TCP/IP        |
        |                 |     |            |           |Appletalk, etc |
        -------------------     --------------           -----------------
                / \                 / \                       / \
                 |                   |                         |
                 |                   |                         |
                 |                   V                         V
                 |             --------------            -----------------
                 |             |block driver|            |network driver |
                 |             --------------            -----------------
                 |                  / \                       / \
                 |                   |                         |
                 |	                 |                         |
                 V                   V                         V
        ---------------------------------------------------------------------------------
        |                              Hardware                                         |
        ---------------------------------------------------------------------------------


	The 'major' and 'minor' numbers identify the driver associated with the device.
	In most cases (but not all) device nodes of the same type (block or character) with the same major number use the same driver.
	Minor numbers are used only by the device driver to differentiate between the different devices it may control.
	mknod() and stat() : return information about 'major' and 'minor' numbers.

	udev:
	-----
	POSIX -- PORTABLE OPERATING SYSTEM INTERFACE
	udev -- user device
	Handles the dynamical generation of device nodes. It replaced devfs and hotplug
	udev Components:
		udev runs a daemon(udevd or systemd-udevd) and monitors a netlink socket.
		mechanism: device --ADDED--> uevent kernel facility --SENDS MESSAGE--> socket --> udev [addes or removes nodes]
		 - libudev -: library which allows access to information about the devices
		 - udevd -: daemon that manages the /dev directory.
		 - udevadm -: utility for control and diagnostics.
	udev main configuration file: /etc/udev/udev.conf
	udev naming rules file: /etc/udev/rules.d
	udev Device Manager:-
		mechanism --: udev[receives message from kernel] --PARSES--> Rule-Setting Files[ in /etc/udev/rules.d/*.rules]
			Actions taken includes:-
				- device node naming
				- device node and symbolic links creation.
				- setting file permissions and ownership for the device node.
				- taking other actions to initialize and make device available.
				These rules are completely customizable
	udev rules are located under:
		/etc/udev/rules.d/<rulename>.rules, e.g. 30-usb.rules, 90-mycustom.rules



							           Create device node in /dev
								                 / \
								                  |
								                  |
								                  |
						                   udevd
						                   /  \
						                  /    \
						                 /      \
						                /        \
						               /          \
	                        /		         \
						       kernel module    Rules database

	Creating udev Rules
		format: <match><op>value [, ...] <assignment><op>value [, ...]

<------------------------------------------------------------------------------------------------------>
					Chapter 9. Partitioning and Formatting Disks

	Schemes are selected based on the following:
		- size of system
		- number of users and their needs
		- type of hardware available
		- type of data bus to which the storage is attached

	Objectives:

		- Describe and contrast the most common types of hard disks and data buses.
		- Explain disk geometry and other partitioning concepts.
		- Understand how disk devices are named and how to identify their associated device nodes.
		- Distinguish among and select different partitioning stratigies.
		- Use utilities such as blkid and fdisk.
		- Back up and restore partition tables

	Common Disk Types:
		- IDE and EIDE(Integrated Drive Electronics, and Enhanced IDE)
			obsolete
		- SATA(Serial Advanced Technology Attachment)
			seen as SCSI devices by the OS
			smaller cable size( 7 pins) when compared to PATA, a.k.a. IDE
			native hot swapping, and faster
			more efficiant data transfer
			can handle 16GB/s, but 3 GB/s and 6 GB/s are more common
		- SCSI(Small Computer Systems Interface)
			lower capacity than SATA
			faster than SATA
			work better in parallel, as when used in RAID configurations
			versions may include:- Fast, Wide, Ultra, and UltraWide
			more varied device drivers unlike SATA
			disk range vary from 8 bit bus to 16 bit bus
			transfer rate of 5 MB/s(narrow, standard SCSI) to about 160 MB/s (Ultra-Wide SCSI-3)
			Single ended device controllers [host up to 7 devices, max cable length 6 meters]
			Differential controllers[host up to 15 devices, max length 12 meters]
		- SAS(Serial Attached SCSI)
			newer point to point serial protocol replacing the earlier Parallel SCSI interface
			data transfer rate similar to SATA
			better performance
		- USB(Universal Serial Bus)
			include pen drives and extensible USB drives
			OS sees them as SCSI devices
			in the same category as SSDs drives
	Disk Geometry:
		- parameters include:-
			heads, cylinders, tracks and sectors
		- Structure:-



		                                                    DISKS
		                                                    / \
		                                                     |
		                                                     |
		                                                     |
		                                                     |
	                -------------------------------------------------------------------------------------------
	                |    Platter                                                         Platter              |
	                -------------------------------------------------------------------------------------------
	                       / \                                                             / \
	                        |								                                                |
                          |								                                                |
	                        |								                                                |
	                        |								                                                |
           --------------------------------------------------------------------------------------------
 		       |                   Cylinders(group of similar platters on all sectors)                    |
 		       --------------------------------------------------------------------------------------------
 		              /   \                                                           /    \
 		             /     \							                                           /      \
 		            /       \                                                       /        \
 		      circular  circular                                              circular   circular
		       tracks    tracks                                                tracks     tracks
		               |								                                               |
		               |							                                                 |
		               |								                                               |
		       -------------------------------------------------------------------------------------------
		       |                           Data Blocks (Sectors)                                         |
		       -------------------------------------------------------------------------------------------
		              / \							                                                 / \
		               |                                                                |
		               |                                                                |
		               |                                                                |
		       -------------------------------------------------------------------------------------------
          |                                 Read by Heads                                           |
           -------------------------------------------------------------------------------------------


	Partitioning:
		disks are divided into partitions based on physically contigious groups of sectors or cylinders.
		SCSI and SATA support up to 15 partitions, where 1-4 are primary and 5-15 logical partitions
			structure:
						Disk
						 |
						 |
						 |
						\ /
		-----------------------------------------------------------------
		|                           Drives                              |
		-----------------------------------------------------------------
		              |			                  |			                  |
		              |			                  |			                  |
		              |			                  |			                  |
	        -----------------------------------------------------------------
	        |                        Partitions                             |
	        -----------------------------------------------------------------
	        	      |			                  |			                  |
	        	      |			                  |			                  |
	               sda                     sdb                     sdc
	               /|\
	              / | \
	             /  |  \
	            /   |   \
	           /    |    \
	          sda1 sda2  sda3 ..


	Why Partition?
		- separation -- separating installation files from user files
		- sharing -- keeping shared resources like /home on central location
		- security -- imposing quotas, permissions and settings
		- size -- preventing accumulated data from crashing OS
		- performance --
		- swap -- hibernation schemes can use this
	Partition Table:
                - The disk partition table is contained within the Master Boot Record(MBR), and the MBR is 512bytes in length.
                  structure is defined by an operating system-independent convention.
                - The parttion table is 64 bytes long and is placed after the 446 byte boot record
                	-: structure -
                	MBR
          ---------  -----
          |          |
          |          |
          |          | 446 bytes --- GRUB program code.
          |          |
          |          |
          |          |
          |          -----
    512   |          -----
    bytes |          | Partition 1 - 16 bytes
          |          |----
          |          | Partition 2 - 16 bytes              <----Partiton Table
          |          |----
          |          | Partition 3 - 16 bytes
          |          |----
          |          | Partition 4 - 16 bytes { 0x55AA }
          |          |
          ---------  -----

          Note: each entry in the partition table 16 bytes long
          	- gives the following information:
          		- Active bit.
          		- Beginning address in cylinder/head/sectors (CHS) format (ignored by Linux)
          		- Partition type code, indicating: xfs, LVM, ntfs, ext4, swap, etc.
          		- Ending address in CHS(also ignored by Linux).
          		- Start sector, counting linearly from 0.
          		- Number of sectors in partion.
          	Linux only uses the last two fields for addressing using the linear block addressing(LBA) method.

Naming Disk Devices and Nodes:
------------------------------
	The Linux kernel interacts at a low level with disks through 'device nodes' normally found in the /dev directory
	Device nodes are accessed only through the infrastructure of the kernel's Virtual File System
	SCSI and SATA:
		first hard disk is /dev/sda
		second hard disk is /dev/sdb
			partitions:
				/dev/sdb1
				/dev/sdc4
	IDE:
		/dev/hda3
		/dev/hdb
More on SCSI Device Names:
--------------------------
	- these are determined by the controller number/ID number combination.



	                               /dev/sda
	                                  /   /dev/sdb
	                                 /    /
	controller 0 => target ID number 1 & 3

        controller 1 => target ID number 2 & 5
                                          \   \
                                           \   \
                                            \  /dev/sdd
                                         /dev/sdc


blkid and lsblk:
----------------
	blkid is a utility to locate block devices and report on their attributes
	blkid works with libblkid library, takes as an argument a particular device or list of devices
	Usage:
		sudo blkid /dev/sda*
	blkid will only work on devices that contain data that is finger-printable; e.g., empty partition will not generate a block-identity UUIO
	blkid - forms of operations:
		1 - searching for a device with a specific NAME=value pair, or
		2 - displaying NAME=value pairs for one or more devices
		lsblk - will represent information in a tree format.
	Linux systems shld use a minimum of two partitions:
		- /root:
			used for the entire logical system

		- Swap:
			used as an extension of physical memory
			used as virtual memory

Backing Up and Restoring Partition Tables:
------------------------------------------
	this helps to restore the former partition of disk if new partition fails
		backup - sudo dd if=/dev/sda of=mbrbackup bs=512 count=1
		restore - sudo dd if=mbrbackup of=/dev/sda bs=512 count=1


Partition Table Editors:
------------------------
	-  fdisk: menu driven partition table editor
	-  sfdisk: non-interactive partition editor program, useful in scripting
	-  parted: GNU partition manipulation program.
	-  gparted: widely used graphical interface to parted

Using fdisk:
------------
	start: sudo fdisk /dev/sdb
		the main (one-letter) commands are:
			-m: Display the menu
			-p: List the partition table.
			-n: Create a new partition.
			-d: Delete a partion.
			-t: Change a partition type.
			-w: Write the new partition table information and exit.
			-q: Quit without making changes.
	cat /proc/partitions - will show you the partition  operating system is currently aware of.


<------------------------------------------------------------------------------------------------------->
                                Chapter 10. Encryption Disks

   Linux distributions most often use the 'LUKS' method amd perform encryption-related tasks using 'cryptsetup'.

OBJECTIVES:
	- provide sound reasons for using encryption and know when it is called for.
	- understand 'LUKS' operations through the use of 'cryptsetup'.
	- be able to setp and use encrypted filesystems and partitions.
	- know how to configure the system to mount encrypted partitions at boot.


Why use encryption:
	    Configuration and using block device level encryption provides one of the strongest protections agianst harm
	    caused by loss or compromise of data contained in hard drives and other media.

	    Note: Encryption can not be carried out on an already existing partition in place without a data copying operation.

	    LUKS:
		block level encryption is provided through the use of LUKS(Linux Unified Key Setup).
		LUKS is highly recommended for portable systems e.g. laptops, tablets, smartphones.

		LUKS         plain dm-crypt volumes      loop-AES     TrueCrypt
		 |	     	   	              |		           |              |
		 |			                    |		           |		          |
		 |--------------------------|--------------|--------------|
						|
						|
						v
				cryptsetup
    LUKS stores all necessary information in the partition header itself, it is rather easy to migrate partitions to other disks or systems.
		LUKS can also be used to transparently encrypt swap partitions.

Cryptsetup:
	command format -
		cryptsetup [option...] <action> <action-specific>
		listing possibilities ->
		cryptset --help
    Using an Encrypted Partition:
    	if the LVM partition '/dev/VG/MYSECRETE already exists the following steps will setup encryption
	--> 1. Make it available to LUKS
	    2. format it
	    3. mount it
	    4. use it
	    5. unmount it
        -->
		sudo cryptsetup luksFormat /dev/VG/MYSECRET -- (if kernel doesn't support the default method used by 'cryptsetup' use sudo cat /proc/crypto to find out which your system supports)
	    	 sudo cryptsetup luksFormat --cipher aes /dev/VG/MYSECRET
	    	 sudo cryptsetup --verbose luksOpen /dev/VG/MYSECRET SECRET
	    	 sudo mkfs.ext4 /dev/mapper/SECRET
	    mount it -->
	    	 sudo mount /dev/mapper/SECRET /mnt
	    unmount it -->
	         sudo umount /mnt
            remove the mapper -->
                 sudo cryptsetup --verbose luksClose SECRET


     Mounting at Boot:
     	    Steps include -->
	    	  - make appropraite entry in /etc/fstab
		  - add entry to /etc/crypttab
		    --such as 'SECRET /dev/mapper/MYSECRET

     Steps for Using LUKS:
     	   - create a partition for the encrypted block device
	   - format with cryptsetup
	   - create an un-encrypted pass through device
	   - format with a standard filesystem such as ext4
	   - mount the filesystem on the encrypted block device


<------------------------------------------------------------------------------------------------->

                  Chp11. Linux Filesystems and the VFS( Virtual File System )

Structure of Linux file system:

	  software <-----> VFS <-----> on-disk filesystem

Objectives:
	- explain the basic filesystem organization.
	- understand the role of the VFS.
	- know what filesystema are available in Linux and which ones can be used on your actual system.
	- grasp why journaling filesystem represent significant advances.
	- discuss the use of special filesystems in Lunux.

Local filesystems generally reside within a disk partition which can be a physical partition on a disk, or a logical partition controlled by a LOGICAL VOLUME MANAGER (LVM).
Filesystems can also be of a network nature and their true physical embodiment completely hidden to the local system across the network.

VFS:
	user software <---------> VFS <---------> actual filesystem
	     	      		   |
				             |
				             |
				             v
			/dev, /sys, /temp, /proc, /run

Journalling Filesystems:
	    These recover from system crashes or ungraceful shutdowns with little or no corruption, and they do so very rapidly.
	    Here operations are grouped into transactions, each must be completeed without error, atomically; otherwise the filesystem is not changed.
	    Examples include:
	    	     - ext3, extension of ext2
		     - ext4, enhanced ext3
		     - reiserfs, formally for linux
		     - JFS, IBM
		     - XFS, RHEL
		     - btrfs, latest journalling filesystem under rapid development.
Current Filesystem Types:
	to see system currently registered and understood filesystem.
	cat /proc/filesystems

Special Filesystems:
	Filestsystem     |        Mount Point        |      Purpose
	------------------------------------------------------------------------------------
	rootfs			                  None			          During kernel load, provides an empty root directory.
	hugtlbfs		                  Anywhere		        Provides extended page access (2 or 4 MB on x86)
	bdev			                    None			          Used for block devices.
	proc			                    /proc			          Pseudo filesystem access to many kernel structures and aubsystems.
	sockfs			                  None			          Used by BSD Sockets.
	tmpfs			                    Anywhere		        RAM disk with swapping, re-sizing.
	shm			                      None			          Used by System C IPC Shared Memory.
	pipefs			                  None			          Used for pipes.
	binfmt_misc		                Anywhere		        Used by various executable formats.
	devpts			                  /dev/pts		        Used by Unix98 pseudo-termionals.
	usbfs			                    /proc/bus/usb		    Used ny USB sub-system for dynamical devices.
	sysfs			                    /sys (or elsewhere)	Used as a device tree.
	debugfs			                  /sys/kernel/debug (or	Used for simple debugging file access.elsewhere)


<---------------------------------------------------------------------------------------------------------------->

			Chpt.12. Filesystem Features: Attributes, Creating, Checking, Mounting
	Objectives:
		- be familiar with concepts such as inodes, directory files and extended attributes.
		- create and format filesystems.
		- check and fix errors on filesystems.
		- mount and unmount filesystems.

	Inodes:
		is a data structure on disk that describes and stores file attributes, including location.
		the ionformation stored includes --
		    > permissions
		    > user and group ownership
		    > size
		    > timestamps (nanoseconds)
		      - last access time
		      - last modification time
		      - change time

	Directory Files:
		  is a particualr type of file that is used to associate file names and inodes.
		  two ways to associate (or link) a file name with an inode:
		      > HARD links point to an inode.
		      > SOFT (or symbolic) links point to a file name which has an associated inode.

		  process references pathname ---> kernel [searches directories to find corresponding inode number]
		  	  	     	      	   	  	    		|
										|
										|
										v
							converts name to inode number ---> loads into memory
	Extended Attributes and lsattr/chattr:
		 extended attributes associate not interpreted directly by the filesystem with files.
		 Namespaces used in fileattributes:
		 	    > user,
			    > trusted,
			    > system - access control list (ACL),
			    > security- SELinux.

format:	  chattr [-|+|=mode] filename (change attribute)
			    lsattr filename   (list file attribute)
	        Namespaces:
			user --
			     flags --> i: immutable, a: append-only, d: no-dump, A: No atime update

       Creating and Formatting Filesystems:
       		utility for formatting (making) filesystem on a partition is 'mkfs'
		        format --> mkfs [-t fstype] [options] [device name], e.g.: sudo mkfs -t ext4 /dev/sda10 OR sudo mkfs.ext4 /sda10

Checking and Fixing Filesystems:
       		utility for checking and fixing any errors in a filesystem is 'fsck'
		        format --> sudo fsck -t ext4 /dev/sda10 OR sudo fsck.ext4 /dev/sda10
		              --> fsck [-t fstype] [options] [device-file]
		Note: SHOULD ONLY BE RUN ON UNMOUNTED FILESYSTEMS.
		to do so run the following command --> sudo touch /forcefsck, sudo reboot


Mount:
		Each file system is mounted under a specific directory as in:
		--> sudo mount -t ext4 /dev/sdb4 /home

		mounting files using label or a UUID
		--> sudo mount /dev/sdb4 /home
		--> sudo mount LABEL=home /home
		--> sudo mount  -L home /home
		--> sudo mount UUID=26d58ee2-94jjjfhv0-vnskjs-44ns48 /home
		--> sudo mount -U UUID=26d58ee2-94jjjfhv0-vnskjs-44ns48 /home
		with mount --help you get a quick summary of mount options

unmount:
		umount [device-file | mount-point]
		--> sudo umount /home
		--> sudo umount /dev/sda3

     Mounting Filesystem at Boot:
     	        this command will show you how to mount all filesystems listed in the /etc/fstab at boot
	        --> cat /etc/fstab

     Listing Currently Mounted Filesystems:
     	        --> mount

     Notes:
	format filesystems --> mkfs
	checking and fixing errors --> fsck
	list file attributes --> lsattr
	change file attribute --> chattr
	list open files --> lsof


  <-------------------------------------------------------------------------------------------------------------------->

                                Chapter 13. Filesystem Features: Swap, Quotas, Usage.

  Linux uses robust 'swap space' implementation through which the virtual memory system permits the apparent use of memory than is physically available.

  Filesystem quotas can be used to administer user account usage of disk space.
  Utilities such as 'df' and 'du' enable easy monitoring of filesystem usage and capacities.


  Objectives:
    - explain the concepts of swap and quotas.
    - use the utilities that help manage quotas: quotacheck, quotaon, quotaoff, edquota, and quota.
    - use the utilities df and du.

  Swap:
    virtual memory in Linux uses the COW(Copy On Write) technique ie:
                PARENT memory
                      ^
                      |
                      |
                      |
            |---------|----------|-----------------|
          child A   child B    child C          child D --> [extra memory sector since a portion of PARENT has changed]

          - when memory pressure is high 'less active memory regions are swapped out to disk' and only recalled when needed.

    - In most cases the recommend swap size is the RAM
    - to see what ure system is currently using for swap areas: $ cat /proc/swaps
                                          and current usage: $ free -options

    - commands invovling swap are:
        - mkswap: format a swap partition or file
        - swapon: activate a swap partition or file
        - swapoff: deactivate a swap partition or file
  Quotas:
    - quotacheck:- generates and updates quota accounting files
    - quotaon:- enable quota accounting
    - quotaoff:- disables quota accounting
    - edquota:- used for editing user of group quotas.
    - quotas:- reports on usage and limits.

    Note:
      Quota operations require the existence of the files 'aquota.user and aquota.group' in the root directory of the filesystem using quotas.

    Setting up Quotas:
      - steps include:-
            -- mount the filesystem with user and/or group quota options:
                --- add the userquota and/or grpquota options to the filesystem entry in /etc/fstab
                --- remount the filesystem (or mount it if new)
            -- run 'quotacheck' on the filesystem to set up quotas.
            -- enable quotas on the filesystem
            -- set quotas with the edquota program.

    Setting up Quotas:
      - in /etc/fstab:- /dev/sda5 /home ext4 defaults,usrquota 1 1
      - then test the system:
        -- sudo mount -o remount /home
        -- sudo quotacheck -vu /home
        -- sudo quotaon -vu /home
        -- sudo edquota someuser

      - fstab options include: usrquota and grpquota

    quotacheck:
      creates/updates the quota accounting files aquota.user and aquota.group for the system

    - to update user files for all filesystems in /etc/fstab with user quota options:
      $ sudo quotacheck -ua

    - to update group files for all filesystems i /etc/fstab with group quota options:
      $ sudo quotacheck -ga

    - to update the user file for a particular filesystem:
      $ sudo quotacheck -u [somefilesystem]

    - to update the group file for a particular filesystem:
      $ sudo quotacheck -g [somefilesystem]

    Note: use -v option to get more verbose output
    Note: quotacheck is generally run:-
          -- when quotas are turned on
          -- fsck reports errors during system start up

    Turning quotas on and off:
      - syntax:
        -- $ sudo quotaon [flags] [filesystem]
        -- $ sudo quotaoff [flags] [filesystem]
          --- where the flags can be:
              -a, --all                 turn off for all filesystems
              -f, --full                turn off
              -u, --user                operate on user quotas
              -g, --group                         "
              -p, --print-state         print whether quotas are on or off
              -x, --xfs-command=cmd     perform XFS quota command
              -F, --format=formatname   operate on specific quota format
              -v, --verbose             print more messgaes
              -h, --help                display help text and exit
              -V, --version             display version information

        -- sudo quotaon -av /dev/sda6 / : group quotas turned on
        -- sudo quotaon -av /dev/sda6 /home : user quotas turned on
        -- sudo quotaoff -av /dev/sda6 / : group quotas turned off
        -- sudo quotaoff -av /dev/sda6 /home : user quotas turned off
        -- sudo quotaon -avu /dev/sda6 /home : user quotas turned on
        -- sudo quotaoff -avu /dev/sda6 /home : user quotas turned off
        -- sudo quotaon -avg /dev/sda6 /home : group quotas turned on
        -- sudo quotaoff -avg /dev/sda6 /home : group quotas turned off

        Note: quota operations will fail if aquota.user and aquota.group do not exist

  Examining Quotas:
    - quota ( or quota -u) for current user
    - quota -g returns ure current group quota
    - with superuser for any user:
            -- sudo quota george
            -- sudo quota gracie

  Setting Quotas:
    only fields that can be modofied are 'soft and hard limits' only
    - edquota -u [username]
    - edquota -g [groupname]
    - edquota -u -p [userproto] [username] : used in scripts
    - edquota -u -p [groupproto] [groupname] : used in scripts
    - edquota -t : to set grace periods

    Note: soft limits may be exceeded for a grace period, hard limits may never be exceeded

  Filesystem Usage:
    df (disk free) examines filesystem capacity and usage
    df -hTi

  Diskspace Usage:
    du (disk usage) shows how much space a directory and its subdirectories are using on a filesystem
    - For current directory: $ du
    - to list all files not directories alone: $ du -a
    - human readable format: $ du -h
    - for specific directory: $ du -h somedir
    - display  only totals: $ du -s



<------------------------------------------------------------------------------------------------------->

                    Chapter 14. The Ext2/Ext3/Ext4 Filesystems

  Most used filesystem, with the ext4 being the latest version.


  Objectives:
    - describe the main features of the ext4 filesystem and how it is laid out on disk.
    - explain the concepts of block groups, superblock, data blocks and inodes.
    - Use the dumpe2fs and tune2fs utilities.
    - list the ext4 filesystem enhancements.

  Ext4 History and Basics:
    Timeline:--> ext2 --> ext3 (with journalling) --> ext4 (extents added for large filesystems)
    RHEL 7 uses XFS as default

  Ext4 Features:

            ext4
              |
              |
            blocks --->[512, 1024, 2048, 4096]
              |
        Pages of Memory -->[x86(4kb page size), x64(8kb page size)]


  Ext4 Layout:

              Disk Blocks
                  |
                  |
              Block Groups0 - n
                  |
      |-------------------------------------------------|
      |                                                 |
  block grp 0                                       block grp 1- n (boot sector is absent)
      |
    |-----------------------------|------------------------|----------------|-----------------|---------------|-----------|
    1024(boot sector)        Superblock             Grp Descriptors  Data block bitmap    inode bitmap   inode Table  data blocks
                                  |                                                                                       |
                                  |                                                                                       |
                                  |                                                                                 pre-allocated to files to improve speed
                                  |
                                  |
                                  |
                                  bit-fields:
                                    used to:
                                      -- ascertain whether or not the FS requires checking when first mounted
                                      -- determine when FS was last checked, both in date and number of mounts

  Block Groups:
    Same as above


  dumpefs:
    - scan filesystem information
    $ sudo dumpe2fs /dev/sda2

  tune2fs:
    -- used to change filesystem parameters
      --- change the maximum number of mounts between filesystem checks(max-mount-count)
          $ sudo tune2fs -c 25 /dev/sda2
      --- change the time interval between checks (interval-between-checks)
          $ sudo tune2fs -i 10 /dev/sda2

      --- list the contents of the superblock including current values of parameters whwich can be changed:
          $ sudo tune2fs -l /dev/sda2


  Superblock Information:
    Contains information about the filesystem including:
        -- mount count and maximum count, set by tune2fs.
        -- block size, set by mkfs
        -- blocks per group
        -- free block count
        -- free inode count.
        -- operating system ID


  Data Blocks and Inodes:
    these are blocks whose bits contain 0 for each free block ot inode and 1 for eachused one.

  Ext4 Filesystem Enhancements:
    - is backwards-compatible with ext3 and ext2
    - increases the maximum fielsystem size to 1 EB (from 16 TB), and the maximum file to 16 TB (from 2 TB).
    - increase without limit the maximum number of subdirectories, which was limited to 32k in ext3
    - splits large files into thr largest possible extents instead of using indirect block mapping.
    - uses multiblock allocation
    - pre-allocate disk space for a file
    - uses allocate-on-flush
    - uses fast fsck
    - uses checksums for the journal which improves reliability
    - uses improved timestamps which is measured in nanoseconds
    - includes snapshot support.


<--------------------------------------------------------------------------------------------------------------------------------->

                    CHAPTER 15. THE XFS AND BTRFS FILESYSTEMS.

  THESE ARE IMPORTANT CHALLENGERS TO THE EXT4 FILESYSTEM.

  OBJECTIVES:
    - Describe the xfs filesystem
    - Maintain the xfs filesystem
    - Describe the btrfs filesystem

  XFS FILESYSTEM:
    originally made by sgi for irix os
    - advatages include:
      -- handle:
          --- up to 16eb(exabytes) for the total filesystem
          --- up to 8eb(exabytes) for an individual file
      -- high performance:
          --- employing dma(direct memory access) i/o
          --- guaranteeing an i/o rate
          --- adjusting stripe size to match underlying raid or  devices
      -- can journal quota information, but leads to decrease in recovery time when a quota-enabled filesystem is uncleanly unmounted
      -- supports extended attributes

  XFS FILESYSTEM MAINTENANCE:
    - advantage:
      -- most maintenance tasks can be done on-line while the filesystem is fully mounted, these include:
          --- defragmenting
          --- enlarging
          --- dumping/restoring
      -- backup and restore can be done with the native xfs utilities:
        --- xfsdump
        --- xfsrestore

  THE BTRFS FILESYSTEM:
    b-tree file system:
      - advantages:
          -- addresses the lack of:-
              --- pooling,
              --- snapshots,
              --- checksums, and
              --- integral multi-device spanning

  <------------------------------------------------------------------------------------------------------------------->

                          CHAPTER 16. LOGICAL VOLUME MANAGEMENT()

  - Permits having one logical filesystem span mutiple physical volumes and partitions while appearing as a simple partition for normal use.
  - Makes shrinking and expanding easy

  OBJECTIVES:
    - Explain the concepts behind
    - Create logical volumes
    - Display logical volumes
    - Resize logocal volumes
    - Use  snapshots

  :
    - breaks up one virtual partition into multiple chunks, each of which can be on different partitions and/or disks.
    - typical  structure or layout
    - striping (splitting of data to more than one disk)

  |-----------------------------------------------------------------------------------------------------------|
  |                                                         LVM                                               |
  |                       ------------------------------------------------------------------------------|     |
  |         FILE SYSTEMS  |          /HOME(EXT3)              ||                /DATA(XFS)              |     |
  |                       |-----------------------------------------------------------------------------|     |
  |  LOGICAL VOLUMES(LV)  | /DEV/PRIMARY_VG/HOME_|V           ||      /DEV/PRIMARY_VG/DATA_|V           |     |
  |                       |-----------------------------------------------------------------------------|     |
  |   VOLUME GROUPS(VG)   |                           PRIMARY_VG                                        |     |
  |                       |-----------------------------------------------------------------------------|     |
  |   PHYSICAL VOLUMES    | /DEV/Sdb1   ||   /DEV/Sdb2        ||     /DEV/Sdc1     ||   /DEV/Sdc2       |     |
  |                       |-----------------------------------------------------------------------------|     |
  |-----------------------------------------------------------------------------------------------------------|

     PARTITIONS           |---------------||-------------|              |----------------||-------------------|
                          | /DEV/Sdb1     || /DEV/Sdb2   |              |  /DEV/Sdc1     ||   /DEV/Sdc2       |
                          |---------------||-------------|              |----------------||-------------------|
                          |------------------------------|              |-------------------------------------|
    PHYSICAL DRIVES       |             /Dev/Sdb         |              |                /Dev/Sdc             |
                          |------------------------------|              |-------------------------------------|



  LVM AND RAID:
    - lvm can be built on raid

  VOLUMES AND VOLUME GROUP:
    - commands:
      -- vgcreate: create volume group
      -- vgextend
      -- vgreduce
      -- pvcreate: convert a partition to a physical volume
      -- pvdisplay: shows the physical volume
      -- pvmove: moves the data from one physical volume group to others
      -- pvremove

  LOGICAL VOLUMES UTILITIES:
    - $ ls -lf /sbin/lv* --> doesn't work on ubuntu trusty

  CREATING LOGICAL VOLUMES:
    - commands:
      -- lvcreate --> allocates logical volumes from within volume groups
      -- lvdisplay --> reports on available logical volumes
    - filesystems are placed in logical volumes and are formatted with mkfs as usual
    - steps:
       -- create partitions on disk drives (type 8e in fdsik)
       -- create physical volumes from the partitions                  --> $ sudo pvcreate /dev/sdc1
       -- create the volumes group                                     --> $ sudo vgcreate -s 16m vg /dev/sdb1
       -- allocate logical volumes from the volume group               --> $ sudo lvcreate -l 50g -n mylvm vg
       -- format the logical volumes                                   --> $ sudo mkfs -t ext4 /dev/vg/mylvm
       -- mount the logical volumes (also update /etc/fstab as needed) --> $ mkdir /mylvm, then --> $ sudo mount /dev/vg/mylvm /mylvm, then --> /dev/vg/mylvm /mylvm ext4 defaults 0 0 ( to the /etc/fstab)

  DISPLAYING LOGICAL VOLUMES:
    - sudo pvdisplay or sudo pvdisplay /dev/sda5
    - sudo vgdisplay or sudo vgdisplay /dev/vg0
    - sudo lvdisplay or sudo lvdisplay /dev/vg0/lvm1

  RESIZING LOGICAL VOLUMES:
    -- with fs:
        -- shrink --> 1. shrink fs 2. shrink volume
        -- expand --> 1. expand volume, 2. expand fs
    -- UTILITY: RESIZEFS
  EXAMPLES OF RESIZING:
        sudo lvextend -l +500m /dev/vg/mylvm
        sudo resizefs /dev/vg/mylvm

    - SHRINK:
        sudo umount /mylvm
        sudo fsck -f /dev/vg/mylvm
        sudo resizefs /dev/vg/mylvm 200m
        sudo lvreduce -l 200m /dev/vg/mylvm
        sudo mount /dev/vg/mylvm

    - NEW VERSIONS OF LVM UTILITY:
      -- sudo
      -- sudo lvextend -r -l +100m /dev/vg/mylvm
      -- sudo lvreduce -r -l -100m /dev/vg/mylvm

    - VOLUME GROUP:
      -- sudo pvmove /dev/sdc1
      -- sudo vgreduce vg /dev/sdc1


  LVM SNAPSHOTS:
    - creates an exact copy of an existing logical volume
    - useful for:
      -- backups, application testing, and deploying vms
    - creating snapshots:
      -- sudo lvcreate -l 128 -s -n mysnap /dev/vg/mylvm
      --- make a mount point and mount the snapshot:
          ---- mkdir /mysnap
          ---- mount -o ro /dev/vg/mysnap /mysnap
      --- to use and remove snapshot:
          ---- sudo umount /mysnap
          ---- sudo lvremove /dev/vg/mysnap


<--------------------------------------------------------------------------------------------------------------------------->

									CHAPTER 17. RAID

- The use of RAID spreads i/o activity over multiple physical disks, rather than just one.
- Its purpose is to enhance data integrity and recoverability in case of failure, as well as to boost performance when used with modern
	storage devices.
- RAID has different levels with vary in their relative strengths in safety, performance, complexity and cost.

OBJECTIVES:
	- explain the concept of raid.
	- summarize raid levels.
	- configure a raid device using the essential steps provided.
	- monitor raid devices in multiple ways.
	- use hot spares.

RAID:
	- meaning reduntant array of independent disk
	- raid can be implemented in 'software' or in 'hardware'
	- simple implementation:-

			512GB hard drives ---> RAID software implementation ---> 1TB DISK

	- disadvantage of raid hardware:
		-- if disk controller fails, it must be replaced by a compatible controller unlike software implementation
			which can allow the disk to work with any controller.
	- the essential features of raid are:
		-- mirroring: writing the same data to more than one disk.
		-- striping: splitting of data to more than one disk.
		-- parity: extra data is stored to allow problem detection and repair, yielding fault tolerance.
		-- Thus use of raid can improve both performance and reliability.
	- raid devices are typically created by combining partitions from several disks together
	- mdadm is used to create and manage raid devices, '/dev/mdx' is equivalent to '/dev/sda1'

RAID LEVELS:
	- many levels exists based on the specification of increasing complexity and use, these are:
		-- raid 0: uses only striping.
			--- advantages:
				---- data spread across multiple disks
				---- improved performance
			--- disadvantages:
				---- no redundancy
				---- no stability
				---- no recovery capabilities
		-- raid 1: uses only mirroring
			--- advantages:
				---- good for recovery as each disk has a duplicate
		-- raid 5: uses rotating parity strip;
			--- advantage:
				---- disk failure only causes drop in performance, no loss of data
				--note: they must be at least 3 disks
		-- raid 6: has striped disks with dual parity,
			--- can handle loss of two disks
			--- requires at least 4 disks
			--- replaces raid 5 due to its stress on hardware
		-- raid 10: is a mirrored and striped data set.
			--- at least 4 drives are needed.
		note: adding more disks improves performance.

SOFTWARE RAID CONFIGURATION:
	- steps for setup includes:
		-- create partitions on each disk (type fd in fdisk)
		-- create RAID device with mdadm
		-- format RAID device
		-- add device to /etc/fstab
		-- mount RAID device
		-- capture RAID details to ensure persistence
	- The command: sudo mdadm -s --> used to stop RAID
	- EXAMPLE:
		- create two partitions of type fd on disks /dev/sdb, /dev/sdc
			-- sudo fdisk /dev/sdb, sudo fdisk /dev/sdc
		- set up the array
			-- sudo mdadm --create /dev/md0 --level=1 --raid-disks=2 /dev/sdbx /dev/sdcx
		- FORMAT IT
			-- sudo mkfs.ext4 /dev/md0
		- ADD TO CONFIGURATION
			-- sudo bash -c "mdadm --detail --scan >> /etc/mdadm.conf"
		- MOUNT IT
			-- sudo mkdir /myraid
			-- sudo mount /dev/md0 /myraid
			-- add /dev/md0 /myraid ext4 defaults 0 2
		- examine /proc/mdstat to see the raid status as in:
			-- cat /proc/mdstat
		- TO STOP
			-- sudo mdadm -s /dev/md0

MONITORING RAIDS:
	- ways include:
		-- sudo mdadm --detail /dev/md0
		-- cat /proc/mdstat
		-- you can also use: mdmonitor, requires the configuration of /etc/mdadm.conf
		-- status of raid device /dev/mdx:
			--- sudo mdadm --detail /dev/mdx
		-- show status of all raid devices on the system
			-- cat /proc/mdstat
		-- monitor raid via email:
			--- mailaddr eddie@haskel.com
			--- starting email service with:
				---- sudo service mdmonitor start
				---- sudo chkconfig <mdmonitor | mdadm> on

RAID HOT SPARES:
	- used to fix redundancies
	- create hot spares for raid
		-- sudo mdadm --create /dev/md0 -l 5 -n3 -x 1 /dev/sda8 /dev/sda9 /dev/sda10 /dev/sda11
		-- switch '-x 1' tells raid to use one hot spares
		-- testing the redundancy and hot spare of your array
			--- sudo mdadm --fail /dev/md0 /dev/sdb2
		-- restoring tested drive:
			--- sudo mdadm --remove /dev/md0 /dev/sdb2
			--- sudo mdadm --add /dev/md0 /dev/sde2

<---------------------------------------------------------------------------------------------------->

						CHAPTER 18. LOCAL SYSTEM SECURITY

OBJECTIVES:
	- assessing system security risks
	- fashion and implement sound computer security policies and procedures
	- efficiently protect bios and the boot loader with passwords
	- use appropraite mount options, setuid and setgid to enhance security
LOCAL SYSTEM SECURITY:
	- can be defined in terms of:
		-- the systems ability to reguralarly do what it is supposed to do
		-- integrity and correctness of system
		-- ensuring that the ayatem is only available to those authorized to use it

	- AREAS FOR SECURITY INCLUDE:
		-- PHYSICAL
		-- LOCAL
		-- REMOTE, AND PERSONAL
CREATING A SECURITY POLICY:
	- basic structure of computer security:
		-- be simple and easy to understand
		-- get constantly updated
		-- be in the form of a written documentation
		-- describe both policies and procedures
		-- specify enforcemant actions
		-- specify actions to take in reesponse to a security breach
	- basic structure of security policies:
		-- should be generic so its easy to follow
		-- must safe the data that needs protections
		-- deny access to required services and protect user policy
	- policies should be updated on a regular basis
WHAT TO INCLUDE IN THE POLICY:
	- methods of protecting information from being read or copied by unauthorized personel
	- protection of information from being altered or deleted without the permission of the ownership
	- all services should be protected so they are available and not degraded in any manner without authorization
	- aspects include:
		-- confidentiality
		-- data integrity
		-- availability
		-- consistency
		-- control
		-- audit
WHAT RISKS TO ASSESS:
	- QUESTIONS ARE:
		-- WHAT DO I WANT TO PROTECT?
		-- WHAT AM I PROTECTING IT AGAINST?
		-- HOW MUCH TIME, PERSONNEL, AND MONEY IS NEEDED TO PROVIDE ADEQUATE PROTECTION?
CHOOSING A SECURITY PHILOSOPHY:
	- BASIC PHILOSOPHIES:
		-- ANYTHING NOT EXPRESSLY PERMITTED IS DENIED
		-- ANYTHING NOT EXPRESSLY FORBIDDEN IS PERMITTED
SOME GENERAL SECURITY GUIDLINES:
	- GENERAL GUIDELINES:
		-- HUMAN FACTOR IS THE WEAKEST LINK:
			--- EDUCATE YOUR USERS AND KEEP THEM HAPPY
		-- NO COMPUTER ENVIRONMENT IS INVULNERABLE
		-- PARANOIA IS A GOOD THING:
			--- BE SUSPICIOUS, VIGILANT, PERSEVERE WHEN SECURING A COMPUTER.
UPDATES AND SECURITY:
	- ALWAYS APLY UPDATES AND UPGRADES
HARDWARE ACCESSIBILITY AND VULNERABILITY:
	- PHYSICAL ACCESS TO SERVERS AND WORKSTATIONS SHOULD MONITORED
HARDWARE ACCESS GUIDELINES:
	- STEPS INCLUDE:
		-- LOCKING DOWN WORKSTATIONS AND SERVERS
		-- PROTECTING YOUR NETWORK LINKS AGAINST ACCESS BY PEOPLE YOU DO NOT TRUSTED
		-- PROTECTING YOUR KEYBOARDS WHERE PASSWORDS ARE ENTERED TO ENSURE THE KEYBOARDS CANNOT BE TAMPERED WITH
		-- PASSWORD PROTECTING BIOS TO PREVENT BOOTING FROM LIVE OR RESCUE CD/DVD OR USB KEY

PROTECTION OF BIOS:
	- SHOULD BE DONE WITH CARE

PROTECTING THE BOOT LOADER WITH PASSWORD:
	- SHOULD BE SECURED WITH THE BIOS FOR FULL PROTECTION
	- STEPS INCLUDES:
		-- GRUB VERSION 1:
			--- RUN GRUB-MD5-CRYPT
			--- COPY DISPLAYED HASHED PASSWORD
			--- EDIT /BOOT/GRUB/GRUB.CONF AND ADD THE LINE BELOW THE TIMEOUT ENTRY:
				---- PASSWORD --MD5 $LKL(8R8LKZ.LJGSOORP)I4MMKKKLXZA
		-- GRUB VERSION 2:
				--- MORE COMPLICATED TO SET UP
				--- EDIT SYSTEM CONFIGURATION FILES IN /ETC/GRUB.D
				--- RUN UPDATE-GRUB
FILESYSTEM SECURITY: MOUNT OPTIONS:
	- NODEV --> DO NOT INTERPRET CHARACTER OR BLOCK SPECIAL DEVICES ON THE SYSTEM
	- NOSUID --> THE SET-USER-IDENTIFIER OR SET-GROUP-IDENTIFIER BITS DO NOT TAKE EFFECTIVE
	- NOEXEC --> RESTRIC DIRECT EXECUTION OF ANY BINARIES ON THE MOUNTED FILESYSTEM
	- RO --> MOUNT THE FILESYSTEM IN READ-ONLY MODE AS IN:
		-- MOUNT -O RO,NOEXEC,NODEV /DEV/SDA2 /MYMOUNTPT
		OR
		-- /DEV/SDA2 /MYMOUNTPT EXT4 RO,NOEXEC,NODEV 0 0

SETUID AND SETGID:
	- USING THIS COMMANDS ONE CAN CHANGE THE DEFAULT BEHAVIOUR OF ANY PROGRAM TO RUN WITH THE PERMISSION OF
		THE OWNER RATHER THAN WITH THAT OF THE CURRENT USER OF THE PROGRAM
SETTING THE SETUID/SETGID BITS:
	- COMMANDS:
		-- CHMOD U+S SOMEFILE
		-- CHMOD G+S SOMEFILE
		-- CHMOD G+S SOMEDIR --> FILES CREATED IN THIS DIRECTORY ARE GROUP OWNED BY THE GROUP OWNER OF THE DIRECTORY.


<------------------------------------------------------------------------------------------------------------------------>

						CHAPTER 19. LINUX SECURITY MODULES
THE RESPONSIBLITY OF PROTECTING A SYSTEM FALLS ON:
	- APPLICATION DESIGNERS
	- LINUX KERNEL DEVELOPERS AND MAINTAINERS

OBJECTIVES:
	- UNDERSTAND HOW THE LINUX SECURITY MODULES FRAMEWORK WORKS AND HOW IT IS DEPLOYED
	- LIST THE VARIOUS LSM IMPLEMENTATIONA AVAILABLE
	- DELINEATE THE MAIN FEATURES OF SELINUX
	- EXPLAIN THE DIFFERENT MODES AND POLICIES AVAILABLE
	- GRASP THE IMPORTSANCE OF CONTEXTS AND HOW TO GET AND SET THEM
	- KNOW HOW TO USE THE IMPORTANT SELINUX UTILITY PROGRAMS

WHAT ARE LINUX SECURITY MODULES?:
	- USING 'MANDATORY ACCESS CONTROLS' LINUX KERNEL ENSURES A SECURE SYSTEM
	- PROTOCOL FOR IMPLEMENTATION ARE:
		-- MINIMIZE CHANGES TO THE KERNEL
		-- MINIMIZE OVERHEAD ON THE KERNEL
		-- PERMITS FLEXIBILITY AND CHOICE BETWEEN DIFFERENT IMPLEMENTATIONS. EACH OF WHICH IS PRESENTED AS A SELF-CONTAINED LSM (LINUX SECURITY MODULE)
		-- BASIC SCENERIO:
			--- REQUEST TO KERNEL SYSTEM ---> KERNEL INVOKES SECURITY SYSTEM
														|
														|
														|				 YES
														|				  |
														V				  V
									DOES USER HAVE RIGHT TO MAKE REQUEST ---> KERNEL CARRIES OUT REQUEST
														|
														|<----NO
														|
														V
											KERNEL DENIES ACCESS TO USER
LSM CHOICES:
	- CURRENT LSMS ARE:
		-- SELINUX -- SECURITY ENHANCED LINUX
		-- APPARMMOR
		-- SMACK
		-- TOMOYO
SELINUX OVERVIEW:
	- USED TO DETERMINE WHICH PROCESSES CAN ACCESS WHICH:-
	 -- FILES
	 -- DIRECTORIES
	 -- PORTS, AND
	 -- OTHER ITEMS ON THE SYSTEM
	- WORKS WITH THESE CONCEPTUAL QUANTITIES:
		-- CONTEXTS: LABELS TO FILES, PROCESSES, AND PORTS, E.G. USER, ROLE, AND TYPE
		-- RULES: IN TERMS OF CONTEXTS, PROCESSES, FILES, PORTS, USERS
		-- POLICIES: SET OF RULES THAT DESCRIBES WHAT SYSTEM-WIDE CONTROL DECISIONS SHOULD BE MADE BY SELINUX

SELINUX MODES:
	- ENFORCING: ALL SELINUX CODE IS OPERATIVE AND ACCESS IS DENIED ACCORDING TO POLICY. ALL VIOLATIONS ARE AUDITED AND LOGGED.
	- PERMISSIVE: ENABLES SELINUX CODE BUT ONLY AUDITS AND WARNS ABOUT OPERATIONS THAT WOULD BE DENIED IN ENFORCING MODE.
	- DISABLED: COMPLETELY DISABLE SELINUX KERNEL AND APPLICATION CODE LEAVING THE SYSTEM WITHOUT ANY OF ITS PROTECTIONS.
	- MODES ARE SELECTED AND EXPLAINED IN A FILE (USUALLY /ETC/SELINUX/CONFIG) WHOSE LOCATION VARIES BY DISTRIBUTION (IS OFTEN EITHER AT
		 /ETC/SYSCONFIG/SELINUX OR LINKED FROM THERE)
	- UTILITIES USED HERE ARE:
		-- SESTATUS: DISPLAY CURRENT MODE AND POLICY
		-- GETENFORCE
		-- SETENFORCE --> $ SUDO SETENFORCE PERMISSIVE
	- TO COMPLETELY DISABLE MODE USE:
		-- CONFIGURATION FILE, /ETC/SELINUX/CONFIG AND SET SELINUX=DISABLED
		-- KERNEL PARAMETER, ADDING SELINUX=0 TO THE KERNEL PARAMETER LIST WHEN BOOTING

SELINUX POLICIES:
	- USUALLY /ETC/SYSCONFIG/SELINUX IS USED TO SET THE SELINUX POLICY.
	- MULTIPLE POLICIES ARE ALLOWED BUT ONLY ONE CAN BE ACTIVE AT A TIME
	- EACH POLICY IS INSTALLED UNDER /ETC/SELINUX/[SELINUXTYPE]
		-- COMMON POLICIES ARE:
			--- TARGETED: DEFAULT POLICY STATE IN WHICH SELINUX IS MORE RESTRICTED TO TARGETED PROCESSES.
				USER PROCESSES AND INIT PROCESSES ARE NOT TARGETED
			--- MINIMUM: HERE ONLY SELECTED PROCESSES ARE TARGETED
			--- MLS" MULTI-LEVEL SECURITY POLICY IS MUCH MORE RESTRICTIVE. HERE ALL PROCESSES ARE ARE PLACED IN A FINED-GRAINED
				SECURITY DOMAINS WITH PARTICULAR POLICIES

CONTEXT UTILITIES:
	- SELINUX CONTEXTS ARE:
		-- USER
		-- ROLE
		-- TYPE
		-- LEVEL
	- SELINUX AND STANDARD COMMAND LINE TOOLS:
		-- PS, LS, CP, MV, AND MKDIR
SELINUX CONTEXT INHERITANCE AND PRESERVATION:
	- NEWLY CREATED FILES INHERIT THE CONTEXT FROM THEIR PARENT DIRECTORY
	- MOVING OR COPYING FILES, IT IS THE CONTEXT OF THE SOURCE DIRECTORY THAT MAY BE PRESERVED
RESTORECON:
	- RESETS FILE CONTEXTS, BASED ON PARENT DIRECTORY SETTINGS.
	- $ RESTORECON -RV /HOME/PETER
SEMANAGE FCONTEXT:
	- USED TO MANAGE THE DEFAULT CONTEXT FOR A NEWLY CREATED DIRECTORY
		-- MKDIR /VIRTUALHOSTS
		-- LS -Z
		-- SEMANAGE FCONTEXT -A -T HTTPD_SYS_CONTENT_T /VIRTUALHOSTS
		-- LS -Z
		-- EFFECTING THE CHANGE ABOVE:
			--- RESTORECON -RFV /VIRTUALHOSTS
			--- LS -Z
USING SELINUX BOOLEANS:
	- SELINUX POLICY BEHAVIOUR CAN BE CONFIGURED AT RUNTIME WITHOUT REWRITING THE POLICY.
	  USING SELINUX BOOLEANS WHICH ARE POLICY PARAMETERS THAT CAN BE ENABLED AND DISABLED.
	- SUDO SEMANAGE BOOLEN -L (LIST BOOLEANS OF CURRENT POLICY, INCLUDING CURRENT STATE AND SHORT DESCRIPTION)
Getsebool and setsebool:
	- getsebool -a --> prints only the boolean name and its current status.
	- setsebool: changing boolean status non-persistently with -p it perssists
	- examples:
		-- getsebool ssh_chroot_rw_homedir
		-- sudo setsebool ssh_chroot_rw_homedir on
		-- sudo reboot --> removes the above changes
		-- sudo setsebool -p ssh_chroot_rw_homedir on --> perssists changes
Troubleshooting tools:
	- example:
		-- echo 'file created at /root' > rootfile
		-- mv rootfile /var/www/html
		-- wget -o - localhost/rootfile
			--- access denied
		-- check error log --> $ tail /var/log/messgaes
			-- sealert -l dskjk03-kjfklj-kkhh-euykj-3455
			-- on rhel 7 --> grep httpd /var/log/audit/audit.log | audit2allow -m mypol
				--->> audit2allow (generates selinux policies) and audit2why (translates selinux into a description of why the access was denied)
		-- correcting access issue --> restorecon -rv /var/www/html/
		-- wget -q -o - localhost/rootfile
			--->> success
AppArmor:
	- is an lsm alternative to selinux
	- used by suse, ubuntu and other destros
	- apparmor:
		- provides mandatory access control (mac)
		- allows administrators to associate a security profile to a program which restricts its capabilities
		- is considered by some to be easier than selinux
		- is considered filesystem-neutral(no security labels required)
	- apparmor supplements the traditional unix discreationary access control (dac) model by providing mandatory access control(mac)
	- in apparmor: violations of the profile are logged and can be turned into a profile based on the programs typical behaviour.

<-------------------------------------------------------------------------------------------------------------------->

							CHAPTER 20. PROCESSES

 - a process is an embodiment of a running application which may or may not consist of mutiple threads
 - processes have both attributes and well-delineated permissions.
 - they must in one of a number of enumerated states, most common being 'running' or 'sleeping'
 - important to know when a process is running in the 'user mode' or 'kernel mode' with elevated privileges for the latter.
 - a number of different ways exist to create 'child' processes and to set and modify their priorities.

OBJECTIVES:
	- describe a process and the resources associated with it
	- distinguish between processes, programs and threads
	- understand process attributes, permissions and states
	- know the difference between running in user and kernel modes
	- describe 'daemon' processes
	- understand how new processes are forked (created)
	- use nice and renice to set and modify priorities

PROCESSES, PROGRAMS AND THREADS:
	- PROCESS:
		-- this is an executing program and associated resources, including environment, open files, signal handlers
		-- the same program may be executing more than once simultaneously and thus be responsible for multiple processes
		-- basic structure

					PROGRAM
						|
						|----> STARTS PROCESS
						|
						V
					 PROCESS --> PROCESS ID (GROUP ID)
						|
						V
	|------------------------------------------------------| --> THREAD ID (PROCESS ID)
	|		|		|		|		|		|		|	   |
THREAD	 THREAD	  THREAD  THREAD  THREAD  THREAD  THREAD  THREAD


THE INIT PROCESS:
	- this is the first user process on the system with a process id = 1
	- remains till shutdown and is the last process to terminate at shutdown
	- ancestral parent of all other user processes
PROCESSES:
	- is an instance of a program in execution
	- may be in a running state, or sleep state
	- each process has:
		-- pid (process id),
		-- ppid (parent process id),
		-- pgi (process group id)
	- any process from the kernel has a '[]' around their names when '$ ps' is run
	- when a parent process dies before a child, the ppid is set to 1 (init), or to 2 in newer systems using 'systemd'
	- when child process terminates normally or abnormally before its parents which has not waited for it and examined its exit code is
		known as a 'zombie (or defunct)' process
	- the parent 'init' process checks on its adopted child processes and lets those who have terminated die gracefully
	- process are controlled 'scheduling', which is preemptive and is only done by the kernel
	- largest pid has been limited to a 16-bit number, or 32768
	- pid_max can be altered in the /proc/sys/kernel/pid_max
PROCESS ATTRIBUTES:
	- these includes:
		-- the program being executed
		-- context (state)
		-- permissions
		-- associated resources
	- context switching: is done by the kerneL

CONTROLLING PROCESSES WITH ULIMIT:
	- ulimit is a built in bash command that display or resets a number of resources limits associated
		with processes running under a shell.
	- run $ ulimit -a
CONTROLLING PROCESSES WITH ULIMIT(CONT.)
	- the 'ulimit -a' values can be changed to:
		-- restrict (limit to a value), or
		-- expand (increase the current limit or value)
	- kinds of limit include:
		-- hard: max value can't be exceeded, set only by root user
		-- soft: the current limiting value which a user can modify but can't exceed hard limit
	- syntax:
		-- $ ulimit [options] [limit]
			--- as in: ulimit -n 1600
		-- permanently changing this values to affect all currently logged in shells one must modify /etc/security/limits.conf, then reboot

PROCESS PERMISSION AND SETUID:
	- process permissions are based on process ownership or user who invoked it.
	- two types of programs exists:
		-- setuid programs, programs marked with an s execute bit. these run with a different ownership from the current invoker
		-- non-setuid programs, that run based on the real user id
MORE ON PROCESS STATES:
	- running:
		-- is either running or sitting in run queues
	- sleeping:
		-- waiting on a request (usually i/o) that was made
	- stopped:
		-- suspended process, using ctrl-z or debugger
	- zombie:
		-- enters the state when it terminates and no other process (usually parent) has inquired about it state.
		-- here all resources are released except its exit state and its entry in the process table
		-- it is adopted by the init (pid=1) or kthreadd (pid=2) when its parent process dies.
EXECUTION MODES:
	- any one process can be in either:
		-- user mode
		-- system mode
	- modes are enforced at hardware level not software level
USER MODE:
	- all process are started in the use mode by default
	- all processes are isolaled in their own environment called process resource isolation
	- system mode processes run in user mode unless they are jumping  into a system called
KERNEL MODE:
	- HERE CPU HAS ACCESS TO ALL HARDWARE ON THE SYSTEM.
DAEMONS:
	- this is a background process whose sole purpose is to provide some specific service to users of the system
	- basics of daemons:
		-- daemons can be quite s=efficient because they are only called when needed
		-- many daemons are started at boot time
		-- daemons names usually end with d
		-- some examples are: httpd, udevd
		-- daemons may respond to external events (udevd), or elapsed time (crond)
		-- daemons generally have no controlling terminal and no standard input/output devices
		-- daemons sometimes provide better security control
KERNEL-CREATED PROCESSES:
	- the kernel directly creates two kinds of processes:
		-- internal kernel processes:
			--- take care of maintanance work
			--- theses often run as long as the system runs
		-- external user processes:
			--- run in user space like normal applications but where started by the kernel
			--- they are few and short lived
		-- to see these:
			--- $ ps -elf
PROCESS CREATING AND FORKING:
	- STEPS:								   THREAD 2
						    CLIENT REQUEST	  /
							  CHILD PROCESS --
							   /              \
							  /                THREAD 1
			                WEBSERVER        /
		                   -- PARENT PROCESS --->
							 \
							  \               THREAD 1
							   \              /
							  CHILD PROCESS --
							CLIENT REQUEST    \
											  THREAD 2

CREATING PROCESSES IN A COMMAND SHELL:
	- STEPS:
		-- USER EXECUTES A COMMAND AT THE COMMAND SHELL:
			---> a new process is created (forked)
			---> a wait call puts the parent to sleep.
			---> the command is loaded onto the child's process space vis the exec system call.
			---> the command conpletes executing, and the child process dies vis the exit system call
			---> the parent shell is re-awakended by the death of the child process and proceeds to issue a new shell command.
			-->> with '&' the parent shell shell skips the wait request and is free to issue a new command immediately
			-->> exceptions are the 'echo' and 'kill' which are built into the shell and no program files are loaded for them to run.
USING NICE TO SET PRIORITIES:
	- process priorities are controlled using the nice and renice commands.
	- scale (least nice, highest priority)-20 to +19(most nice, lowest priority)
	- syntax:
		-- nice -n 5 command [args]
		-- nice -5 command [args]
MODOFIEDDIFYING THE NICE VALUE:
	- only the superuser can run nice or renice
	- editing the /etc/security/limit.conf
		-- renice +3 13848
		-- man renice for more info
STATIC AND SHARED LIBRARIES:
	- programs are built using libraries of code.
	- static:
		-- the code for the libraries functions are inserted into the program at compile time and
			does not change thereafter even if the library is updated
	- shared:
		-- code is loaded at run time and if updated the program will use the new library.
		-- advantages:
			-- shared by applications
			-- better memory useage
			-- smaller more manageable executable sizes
			-- called dll (dynamic link library)
SHARED LIBRARY VERSIONS:
	- name convention: sharedlib.so.n --> where n = version number
FINDING SHARED LIBRARIES:
	- ldd: used to accertain what shared libraries an executable requires.
	- $ ldd /usr/bin/vi
	- ldconfig:
		-- usually run at boot time but ccan be run anytime and uses the /etc/ld.so.conf
		-- shared libs should only be stored in system directories




<----------------------------------------------------CHAPTER 21-------------------------------------------->
SIGNALS

WHAT ARE SIGNALS?
     sending signals takes three forms:
     	     - kill, killall, pkill
     paths taken by a signal:
     	   - from kernel to a user process as a result of programming error.
	   - from user process (using a system call) to the kernel which will then sebd it to a user process.
	   note: signals can only be sent between processes owned by same user or from superuser to any process
	   sigkill and sigstop cannot be handled and will always terminate the program.

     TYPES OF SIGNALS:
     	   signals are used to handle two things:-
	   	   - exceptions detected by hardware
		   - exceptions generated by the environment
	   $ KILL -L:
	     shows list of signals
             use: $ kill 1991, $ kill -9 1991, $ kill -sigkill 1991

 killall and pkill:
 	 killall - kills all processes
 	 	 use: $ killall bash, killall -9 bash, killall -sigkill bash
 	 pkill - senda a signal to a process using selection criteria
	       uses: $ pkill [-signal] [options] [pattern]
	       	     $ pkill -u libby foobar

<---------------------------------------CHAPTER 22----------------------------------------------------------->

SYSTEM MONITORING

SYSTEM MONITORING TOOLS INCLUDE: TOP, PS, AND SAR. THESE ACCESS THE PSEUDO-FILE SYSTEM /PROC, AND /SYS

AVAILABLE MONITORING TOOLS:
	  process and load monitoring utilities:-
	  	top        process activity, dynamically updated
		  uptime     how long the system is running and the average load
		  ps 	       detailed information about processes
		  pstree     a tree of processes and their connections
		  mpstat     multiple processor usage
		  iostat     cpu utilization and i/o statistics
		  sar	       display and collect information about system activity
      numstat    Information about NUMA (Non-Uniform Memory Architecture)
      strace     Information about all system calls a process makes

      Memory Monitoring Utilities:-
          free        Brief summary of memory usage
          vmstat      Detailed virtual memory statistics and block I/O,
                       dynamically update
          pmap        Process memory map

      I/O Monitoring Utilities:-
          iostat    same as above
          sar       same as above
          vmstat    same as above


      Network Monitoring Utilities:-
          netstat       Detailed networking statistics
          iptraf        Gather information on network interface
          tcpdump       Detailed analysis of network packets and traffic
          wireshare     Detailed network traffic analysis
/proc Basics:
    All important processes have a subdirectory in /proc
    $ ls -F /proc
    $ ls -lF /proc/16477
    $ cat /proc/16477/status

/proc/sys:
    Most tunenable system can be found in this directory
    steps:
        $ ls -l /proc/sys/kernel/threads-max
        $ cat /proc/sys/kernel/threads-max

        sudo bash -c 'echo 100000 > /proc/sys/kernel/threads-max'
        OR
        sudo sysctl kernel.threads-max=100000

/sys Basics:
    Conceptually it is part of the Unified Device Model

sar:
    Systems Activity Reporter
    -gathers system activity and performance data and creating reports that
      are readable by humans.

<----------------------------------------------------Chapter 23---------------------------------------------------------->

Process Monitoring

The major tool for doing this are the 'ps' and 'top' programs


Objectives:

	- use ps to view characteristics and statistics associated with processes
	- identify diff ps output fields and customize the ps output
	- use pstree to get a visual descriotion of the processes ancestry and multi-threaded applications
	- use top to view system loads interactively

Monitoring:
	utilities:-
		top - process activity, dynamically
		uptime - hw long the ayatem is running and average load
		ps - detailed information about processes
		pstree - tree of processes and their connections
		mpstat - multiple processor usage

Viewing Processes States with ps:
	ps get its information from the /proc directory
	versions include:
		 - UNIX with options preceded by '-'
		 - BSD   "      "       "      " '-'
		 - GNU   "      "	"      " '--'


BSD Option Format for ps:
    usage: ps aux
    USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    -- meaning:
       VSZ -> virtual memory size in KB
       RSS -> resident set size; the non-swapped physical memory a task is using in KB
       STAT -> state of the process
       	    -- S -- sleeping
	    -- < high priority(not nice)
	    -- N for low priority (nice)
	    -- L for having pages locked in memory
	    -- s for session header
	    -- l for multi-threaded
	    -- + for being in the foreground process group

     -- adding f option shows how processes connect by ancestry $ ps auxf


UNIX Option Format for ps:
     $ ps -elf
     F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
     Common selection options for UNIX:
     	    -A or -e: select all processes
	    -N: Negate selection
	    -C: Select by command name.
	    -G: Select by real group ID (also supports names)
	    -U: Select by real user ID (also supports names)



Customizing the ps Output:
	    output options:
	    	   - pid: process id number
		   - uid: user id number of process owner
		   - cmd: command with all arguments
		   - cputime: cumulative CPU time
		   - pmem: memory ratio between process and physical memory
	    $ ps -o pid,uid,command
	    for more options do $ ps help


Using pstree:
      $ pstree -aAp 2408
      another method to see children of a process:
      	      $ ls -l /proc/1377/task

Viewing System Loads with top:
	$ top

<----------------------------------------------Chpter 24------------------------------------------------------>
						      I/O Monitoring and Tunning

Two main tools for use in identifying and isolating problems are:
    iostat and iotop
    ionice is used to prioritize the competetion between processes as well


Learning Objectives:
	- use iostat to monitor I/O device activity
	- use iotop to display a constantly updated table of current i/O usage
	- ionice to set both the I/O scheduling class and priority for a given process


Disk Bottlenecks:
     - could be caused by slow I/O


iostat:
	$ iostat
					Result:

	Linux 4.4.0-43-generic (george-HP-Pavilion-17-Notebook-PC) 	16/10/2016 	_x86_64_	(4 CPU)

	avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          	  44.13    0.01    8.95    1.82    0.00   45.11

	Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
	sda              12.74       150.85       120.73    3886066    3110181
	scd1              0.00         0.00         0.00         84          0

	Meaning: tps -> transactions per sec

iostat Options:
       $ iostat -k --> in kB
       $ iostat -m --> in MB
       $ iostat -N --> show device name
       $ iostat -d --> device
       $ iostat -xk --> -x for extended
       Extended:
		Linux 4.4.0-43-generic (george-HP-Pavilion-17-Notebook-PC) 	16/10/2016 	_x86_64_	(4 CPU)

		avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          		  45.65    0.01    9.03    1.70    0.00   43.62

		Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
		sda               1.63    14.94    7.31    5.00   143.87   122.84    43.31     0.30   24.26   20.35   29.97   3.66   4.51
		scd1              0.00     0.00    0.00    0.00     0.00     0.00     8.84     0.00    1.05    1.05    0.00   1.05   0.00




iotop:
	Note: must be runas root
	$ sudo iotop
	  - be --> best effort
	  - rt --> real time
	- $ iotop -o --> can be used to avoid cluttered result


Using ionice to Set I/O Priorities:
      - let you set both the I/O scheduling class and priority for a given process
      - $ ionice [-c class] [-n priority] [-p pid] [COMMAND [ARGS]]



<-------------------------------------------------------Chpt 25----------------------------------------------------------->

                                        I/O Scheduling

System performance often depends very heavily on optimizing the I/O scheduling strategy.

Objectives:

  - explain the importance of I/O scheduling and descibe the conflicting requirements that needs to be satisfied
  - delineate and constrast the options available under linux
  - understand how the CFQ (Completely Fair Queue) and Deadline algorithms works.

I/O Scheduling:

  VM (Virtual Machine) & VFS (Virtual File System)

                    |
                    |
                    V
        I/O Scheduling Layer --> prioritize and order requests
                      |
                      |
                      V
                 Block Devices


I/O Scheduler Choices:

  - CFQ, DEadline, noop

I/O Scheduling and SSD Devices:

  determining if a device is SSD: $ cat /sys/block/<device>/queue/rotational
  - this does not require an elevator scheduling scheme.


<-------------------------------------------------chpter 26------------------------------------->
                                  Memory: Monitoring Usage and Tuning

Objectives:
  - list the primary (inter-related) considerations and tasks invovled in memory tuing
  - know how to use entries in /proc/sys/vm, and /proc/meminfo
  - use vmstat to display information about memory, paging and selects which and processes' memory consumption.
  - understand how the OOM-killer decides when to take action and selects which processes should be exterminated to open some memory.


Memory Tuning Considerations:

Memory MOnitoring Tools:
  Utility         | Purpose                                                     |  Package
  free            | Brief Summary of memory usage                               | procps
  vmstat          | Detailed viryual statics and block I/O, dynamically updatad | procps
  pmap            | Process memory map                                          | procps

/proc/sys/vm:

vmstat:
  vmstat [options] [delay] [count]

  vmstat 2 4
  vmstat -a 2 4 => active and inactive devices
  vmstat -s => memory statistics and certain event counters
  vmastat -d => disk statistics
  vmstat -p /dev/sda1 2 4 =>disk statistics on only one partition

/proc/meminfo:
  cat /proc/meminfo

OOM Killer:
  Out Of Memory Killer (OOM Killer)
  This determines which process gets killes or terminated during insufficient memoey:
    - oom_score


<-----------------------------------------------Chapter 27-------------------------------------------->
                                  Package Management Systems

Objectives:
  - explain s=why software packages management systems should be used
  - understand the role of both binary and source packages
  - list the main available packages management systems
  - understand who two levels of utilities are needed; one that deals with just bare packages, and one that deals with
    dependencies among packages
  - explain how creating your own packages enhances the control you have over exactly what goes in software and how it is installws
  - understand the role of source control systems and git in particular


  Software Packaging Concepts:


  Why Use Packages:
    - automation
    - scalability
    - repeatability
    - security and auditing

  Package Types:
    - Binary --> platform dependent
    - Source --> one used for many platforms, produces binary files
    - Architecture-independent --> run under scripts interpreters, documentation and configuration files
    - Meta-packages --> groups of associated packages that collectively hold everything needed to install a large subsystem

  Available Package Management Systems:
    - RPM --> Red Hat Package Manager
    - dpkg --> debian package

  Packaging Tool Levels and Varieties:
    - Low level Utility:
      -- dependencies are not fully handled
      -- installation, varification, upgrade, removal
      -- rpm dpkg
    - High Level Utility:
      -- dependcies handled
      -- e.g. rpm, apt-get apt-cache, yum, zypper

  Package Sources:
    - maintained by the distributors

<--------------------------------------------Chapter 28--------------------------------------->
                                        RPM
Objectivees:
  - understand how the RPM system is organized and what major operations the rpm program can accomplish
  - explain the naming conventions used for both binary and source rpm files.
  - know how to query, verify, install, uninstall, upgrade and freshen packages.
  - grasp why new kernels should be installed rather than upgrade
  - know how to use 'rpm2cpio' to copy package files into a cpio archive, as well as extract the files without installing them


RPM:
  Redhat Package Manager -
    -- has the following information:
      > how and where to install
      > how and where to uninstall
      > dependencies information - Note: unless a URL is supplied it installs from only local machine using absolute or relative paths
      > distribution dependent - installing on only target machines or OSs

Advatages of Using RPM:
> For system admins:
  - determine what packages (if any) any file on the system is part of
  - determine what version is installed
  - install and uninstall without leaving debris behind
  - determine if a package was installed corectly
  - distinguish documentation files from package files and determine if to install the fomer
  - use ftp or HTTP to install packages over the internet
> For developers:
  - source packagecan be used to build on more than one OS
  - more than one architecture can be used to build from one source package

Package FIle Names:
  - binary naming standard:
    -- <name>-<version>-<release>.<distro>.<architecture>.rpm
        sed-4.2.1-10.el6.x86_64.rpm
    -- <name>-<version>-<release>.<distro>.src.rpm
        sed-4.2.1-10.el6.x86_64.src.rpm

Database Directory:
  - default location is '/var/lib/rpm'
  - '--dbpath' is used to specify a different path
  - '--rebuilddb' option to rebuild the database indeices

Helper Programs and Modifying Settings:
  - location '/usr/lib/rpm'
  - to list helper lib: '$ ls /usr/lib/rpm | wc - l'
  - you can use a 'rpmrc' to specify default settings for 'rpm'
  - 'rpm'  search locations include:
    -- /usr/lib/rpm/rpmrc, /etc/rpmrc, ~/.rpmrc
  - alternative rpmrc file can be specified using the --rcfile option

Queries:
  - $ rpm -q bash - version installed
  - $ rpm -qf /bin/bash - package file came from
  - $ rpm -ql bas - files installed by this package
  - $ rpm -qi bash - information about this package
  - $ rpm -qip foo-1.0.0.1.noarch.rpm - information form package file not data base
  - $ rpm -qa - list all install packages on this system
  - $ rpm -qp --requires foo-1.0.0.1.noarch.rpm - list of prerequisites for package
  - $ rpm -q --whatprovides libc.so.6 - show what installed package provides a particular requisite package

Verifying Packages:
  - $ rpm -Va
  - S -- file size differs
  - M -- file permission or type differs
  - 5 MD5 checksum differs
  - D - device major/minor number mismatch
  - L - symbolic link path mismatch
  - U - user ownership differs
  - G - grp ownership differs
  - T - modification time differs
  - P - capabilities differs

Installing Packages:
  - $ sudo rpm -ivh foo.1.0.0.1.noarch.rpm
  - checks performed at install:
    -- performs dependencies check
    -- conflicts check
    -- runs commands needed before installation
    -- manages configuration files
    -- unpacks files from packages
    -- runs commands needed after installation
    -- updates the system RPM database

Uninstalling pacakges:
  - $ sudo rpm -e system-config-lvm [ will fail if package is not there or is required by other packages]
  - testing for potential failure:
    -- $ sudo rpm -e --test -vv xz

Upgrading Packages:
  - $ sudo rpm -Uvh bash-4.2.45-5.el7_0.4.x86_64.rpm
  - Downgrade:
    -- sudo rpm -Uvh --oldpackage bash-4.2.45-5.el7_0.4.x86_64.rpm

Freshening Packages:
  - $ sudo rpm -Fvh *.rpm

Upgrading the Kernel:
  - Never do a kernel upgrade rather do an install:
    -- $ sudo rpm -ivh kernel-{version}.{arch}.rpm

Using rpm2cpio:
  - extracting a package without installing it:
    -- create cpio:
      --- $ rpm2cpio foobar.rpm > foobar.cpio
    -- list files in an rpm:
      --- $ rpm2cpio foobar.rpm | cpio -t or rpm -qilp foobar.rpm
    -- extract onto the system:
      --- $ rpm2cpio bash-4.2.45-5.el7_0.4.x86_64.rpm | cpio -ivd bin/bash
      --- $ rpm2cpio foobar.rpm | cpio --extract --make-directories


<------------------------------------------- Chapter 29 DPKG ---------------------------------------->
                        Debian Package Manager

Objectives:
  - uses
  - naming convention
  - know what sources packages look like
  - use querying and verifying operations on packages
  - install, upgrade, and uninstall Debian packages

DPKG Essentials:
  - extensions '.deb'
  - folder: /var/lib/dpkg

Package File Names:
  - <name>_<version>-<revision_number>_<architecture>.deb
    -- logrotate_3.8.7-1_amd64.deb
    -- logrotate_3.8.7-1ubuntu_amd64.deb

Source Packages:
  - 3 files found there are:
    -- upstream tarball, ending .tar.gz
    -- description file, ending .dsc
    -- contains patches, .debian.tar.gz or .diff.gz
  - apt-get source logrotate
  - ls -lR logrotate*

DPKG Queries:
  - $ dpkg -l - list all packages
  - $ dpkg -L wget - list files installed in the 'wget'
  - $ dpkg -p wget - show info about 'wget'
  - $ dpkg -I wefs_1.21_ds1-8_amd64.deb - show info about package
  - $ dpkg -c wefs_1.21_ds1-8_amd64.deb - list files in a package file
  - $ dpkg -S /etc/init/networking.conf - show what packages owns
  - $ dpkg -s wget - show status of package
  - $ dpkg -V package - verify

Installing and Upgrading and Uninstalling Packages:
  - $ sudo dpkg -i foobar.deb
  - $ sudo dpkg -r package
  - $ sudo dpkg -p package


<---------------------------------------- Chapter 30 ------------------------------------------------->
                                YUM
Objectives:
  - high level program that uses 'rpm' but is able to resolve dependencies suing remote repos
  - structure:    rpm --> yum --> OS user

What is yum?
  - $ yum cleam [packages | metadata | expire-date | rpmdb | plugins | all ] - removes yum cached information

Configuring yum to Use Repositories:
  - $ ls -l /etc/yum.repos.d - shows list of repos configured with 'yum'

Repository Files:
  - Simple repo:
    -- [repo-name]
        name=Description of the repository
        baseurl=http://somesystem.com/path/to/repo
        enabled=1
        gpgcheck=1

    -- toggle repo on or off using:
      --- --disablerepo=somerepo and --enablerepo=somerepo when using 'yum'

Queries:
  - $ sudo yum search keyword - information about package
  - $ sudo yum list "*keyword*" - what is installed and what else is available
  - $ sudo yum info package
  - $ sudo yum list [installed | updates | available ]
  - $ sudo yum grouplist [group1] [group2]
  - $ sudo yum groupinfo [group1] [group2]

  - $ sudo yum provides "/logrotate.conf" - show packages that conatain file name

Verifying Packages:
  - package verification requires the installation of the 'yum-plugin-verify'
  - $ sudo yum verify [package]
  - $ sudo yum verify-rpm [package]
  - $ sudo yum verify-all [package]


Installing/Removing/Upgrading Packages:
  - sudo yum install package2 [package2]
  - sudo yum localinstall package-file
  - sudo yum groupinstall group-name or sudo yum install @group-name
  - sudo yum remove package1 [package2]
  - sudo yum update [package]

Additinal Commands:
  - sudo yum list "yum-plugin" -- install to use more yum commands
    - sudo yum repolist
    - sudo yum shell [text-file]
  - sudo yum install --downloadonly package for commands below to work
    - sudo yumdownloader pacakge
  - sudo yum history


<------------------------------------------------------ Chapter 31 --------------------------------------------------------------->

Objectives:
  - explain what zypper is
  - discuss the queries zypper can be used for
  - install. remove and upgrade packages using zypper

What is zypper?
  - command line tool for installing and managingg packages in SUSE Linux and openSUSE
  - similar to 'yum' and 'apt-get'

Zypper Queries:
 *Zypper is similar to 'yum' queries
  - $ zypper list-upgrades
  - $ zypper repos - list available repos
  - $ zypper search <string>

Installing/Removing/Upgrading:
  - install or update -- $ sudo zypper install package
  - No confirmation when installing -- $ sudo zypper --non-interactive install <package>
  - update installed packages -- sudo zypper update
  - Non-interactive -- $ sudo zypper --non-interactive update
  - remove a package -- $ sudo zypper remove <package>

Additional zypper Commands:
  - When zypper commands must be run in a sequence -- $ sudo zypper shell

  - add a repo -- $ sudo zypper addrepo URI alias
  - remove a repo from the list -- $ sudo zypper removerepo alias
  - find which package provides a file -- $ sudo zypper waht-provides <file-path>


<------------------------------------------------- Chapter 32 ------------------------------------------->
                                                    APT
Advanced Packaging Tool -
  - main utilities are 'apt-cache' and 'apt-get'

Objectives:
  - explain APT
  - user apt-cache
  - install, remove, and upgrade packages using 'apt-get'

What is APT:
  - advanced packaging tool laid on top of 'debian dpkg'

apt-get:
  - install, manage and update

Queries Using apt-cache:
  - $ apt-cache search apache2
  - $ apt-cache show apache2 -- show basic information
  - $ apt-cache showpkg apache2 -- show detailed information
  - $ apt-cache depends apache2 -- show dependent packages
  - $ apt-file search apache2.conf --search the repo for a file named apache2.conf
  - $ apt-file list apache -- list all files in the apache2
  - $ apt-file find <file path> -- used to find which package provides the file specified

Installing/Removing/Upgrading:
  - available package list on debian -- /etc/apt/aources.list
  - sudo apt-get update
  - sudo apt-get install [package]
  - sudo apt-get remove [package]
  - sudo apt-get --purge remove [package] -- remove with config file
  - sudo apt-get upgrade - upgrade all installed packages
  - sudo apt-get dist-upgrade -- smart upgrade
  - sudo apt-get autoremove -- remove unneeded packages
  - sudo apt-get clean -- clean out cached files

<---------------------------------------------- Chapter 33 ------------------------------------------->
                                        User Account Management

Objectives:
  - explain the purpose of individual user accounts and list its main attributes
  - create, modify, remove, and lock accounts
  - understand how user passwords are set, encrypted and stored, how to require changes in password over time due to security
  - explain how restricted shells and restricted accounts work
  - understand the role of root account and when to use it

User Accounts:
  - purposes include:
    -- provide each user with their own individualized private space
    -- for specific dedicated purposes
    -- distinguisheing privileges among users
    -- Note: the 'daemon' account exists to allow processes run as a user other than root

Attributes of User Account:
  - The seven elements are:
    -- user name
    -- user password
    -- user identification number (UID)
    -- group identification number (GID)
    -- comment or GECOS --> information on the user
    -- Home directory
    -- Login shell

Creating User Accounts with useradd:
  - $ sudo useradd koko
    -- steps:
        -> next available UID greater than UID_MIN (as specified in /etc/login.defs) is assigned as koko's UID
        -> group called 'koko' with GUI=UID is also created as koko's default group
        -> home directory /home/koko is created
        -> koko's login shell will /bin/bash
        -> contents of 'etc/skel' is copied to '/home/koko'
        -> an entry of !! or ! is placed in the password filed of the ''/etc/shadow' file for koko's entry thus requiring the admin to assign a password for account to be useable
    -- defaults can also be overruled:
      - $ sudo useradd -s /bin/bash -m -k /ec/skel -c "Bullwinkle J Marxh" bmoose

Modifying and Deleting User Accounts:
  - $ sudo userdel isable -- all refrences to user in '/etc/passwd', '/etc/shadow' and '/etc/group'
  - $ sudo userdel -r isabel -- will also remove '/home/isabel' leaving files owned by user on system
  - Change the xteristices of a user using, '$ sudo usermod' for options see '$ sudo usermod --help'

Locked Accounts:
  - locked account means user or programs cannot login into system
  - means of keeping a user out includes:
    -- $ sudo usermod -L koko --> 'unlock' $ sudo usermod -U
    -- $ sudo chage -E 2014-09-11 koko -> change expiration date
    -- edit '/etc/shadow' and add 'any invalid string'

User IDs and /etc/password:
  - always use 'usermod or vipw' to edit or change values in '/etc/passwd, /etc/group, /etc/shadow'

/etc/shadow:
  - fields here include:
    -- username
    -- password
    -- lastchange
    -- mindays -> min days before which password must be changed
    -- maxdays -> days after when password must be changed
    -- warn -> before passwrd expires
    -- grace -> days after passwd expire that account is disabled
    -- expire -> date account will be disabled
    -- reserved -> reserved field
Password Management:
  - user changing own password -> $ passwd
  - root changing user password -> $ sudo passwd koko

Chage: Password Aging
  - used to setup password xteristics
  - chage [-m mindays] [-M maxdays] [-d lastday] [-I inactive] [-E expiredate] [-W warndays]
  - user can only use 'chage' to see their aging: $ sudo chage -l coop
  - forcing user to change password at next login: $ sudo chage -d 0 USERNAME

Restricted shell:
  - Under Linux this is used to restrict the user: '$ /bin/bash -r'
     --

Restricted Accounts:
  - helps to:
    -- uses the restricted shell
    -- limits available system programs and user applications
    -- limits system resources
    -- limits access times
    -- limits access locations
  - to create it:
    - cd /bin ; sudo ln -s bash rbash
    - cd /bin ; sudo ln bash rbash
    - cd /bin ; sudo cp bash rbash
       -- then use /bin/rbash in the /etc/passwd

The root Account:
   - Root login is permitted only from the devices listed in '/etc/security'

SSH:
  - steps to login via ssh:
    -- whoami
    -- $ ssh aomesite.com
    -- as another user:
      -- $ ssh root@somesite.com or $ ssh -l root somesite.com
    -- copy files:
      --> $ scp file.txt somesite.com:/tmp
      --> $ scp file.txt student@somesite.com/gome/student
      --> $ scp -r some>dir somesite.com:/tmp/some_dir
    -- on multiple machines:
      -- $for macines in node1 node2 node3
         do (ssh $machine some_command &)
         done

ssh Configuration Files:
  - user configurations are stored in the .ssh directory
  - ls -l ~/.ssh

<-------------------------------------------- Group Management ------------------------------------------------>
                                                  Chapter 34

Learning Objectives:
  - explain why it is useful to have Linux users belong to one or more groups
  - use utilities such as 'groupadd, groupdel, groupmod' and 'suermod' to create, remove and manipulate groups and their membership
  - describe User Private Groups
  - explain the concept of group membership
Groups:
  - purpose include:
    - allow users to share a work area
    - setting up file permissions
    - permitting certain specific users to access resources they would normally not be allowed to otherwise

    - Groups are defined in '/etc/group' and the file looks like this:
      -- groupname:pasword:GID:user1,user2,...
      where:
        - groupname --> name of group
        - password --> is the password place-holder, group passwords maybe set, but only if the '/etc/gshadow' file exists
        - GID --> is the group identifier
                  - values btween 0 and 99 are for system groups
                  - btween 100 and GID_MIN (as set in /etc/login.defs and usually the same as UID_MIN) are considered special
                  - over GI_MIN are for UPG (User Private Groups).
        - user1, user2, ... --> list of users who are members of the group

Group Management:
  - groupadd --> add new group
  - groupdel --> remove group
  - groupmod --> modify a groups's properties
  - usermod --> modify a user's group membership (add or remove)

  One can also edit the /etc/group directly but use of vigr is better as it is kinked to the vipw

  The group manipulation utilities modify /etc/group and (if it exists) /etc/gshdow

User Private Groups:
  - the idea is that each user will have his or her own private group, but UPG are guaranteed to be private, additional members may be added to that group
  - all users are created with GID = UID
  - umask is set to 002 for all users created with UPG. Files = 644, directories = 775

Group Membership:
  - user have one primary group but may have between 0 to 15 secondary groups
  - group membership identification:
    - $ groups [user1 user2  ...]
    - $ id -Gn [user1 user2 ...]

<------------------------------------------------------------ File Permissions and Ownership ------------------------------------------->
                                                                       Chapter 35

DAC - directory access control

Learning Objectives:
  - explain the concepts of owner, group, and world
  - set file access rights (read, write, and execute) for each category
  - authenticate requests for file access, respecting proper permissions
  - use chmod to change file permissions, chown to change user ownership, and chgrp to change group ownership
  - understand the role of umask in stablishing desired permission on newly created files.
  - user ACLs to extend the simpler user, group, world and read, write, execute model.

Owner, Group and World:
  - -rw-rwr-- 1 coop aproject 1601 Mar 9 15:04 a_file

File Access Rights:
  - specialized permissions -- setuid & setgid

File Permission and Security and Authentication:
  - Order of authentication:
    -- if the requester is the owner, the file owner permission are used
    -- otherwise, if the requester is in the group that owns the files, the group permissions are examined
    -- if that doesn't succeed, the world permissions are examined.

Changing Permissions: chmod:
  - chmod uo+x,g-w a_file

chmode: Numerical Syntax fro Permissions:
  - octal form --> 0755
  - symbolic form --> u+rwx,g+rwx,o+rx
  - 4 - read, w - write, x - execute

Changing User and Group File Ownership: chown and chgrp:
  - chown coop:aproject a_file

umask:
  - default permissions for:
    -- file --> 0666
    -- folder --> 0777
  - using 'umask':
    - for file of 0666 --> 0666 & ~002 = 0664; folder --> 0777 & ~002 = 0775;
  - change 'umask':
    - $ umask 0022

Filesystem ACLs:
  - Access Control Lists:
    - with this its possible to grant specific users or groups particular privileges without using 777 permissions
    - default set of ACLs is created at system install.

Getting and Setting ACLs:
  - To see ACLs:
    - getfacl file|directory
  - To set ACLs:
    - setfacl options permissions file|directory
    - $ setfacl -m u:isablella:rx /home/george/file2
    - $ setfacl -x u:isabella /home/george/file
    Note: 'mv' and 'cp -p' preserve ACLs
  - To remove ACLs:
    - setfacl -x u:isabella /home/george/file1
  - To set the default on directory:
    - $ setfacl -m d:u:isabella:rx somedir

<-------------------------------------------------------- File Permissions and Ownership ------------------------------------------->
                                                                       Chapter 35

DAC - directory access control

Learning Objectives:
  - explain the concepts of owner, group, and world
  - set file access rights (read, write, and execute) for each category
  - authenticate requests for file access, respecting proper permissions
  - use chmod to change file permissions, chown to change user ownership, and chgrp to change group ownership
  - understand the role of umask in stablishing desired permission on newly created files.
  - user ACLs to extend the simpler user, group, world and read, write, execute model.

Owner, Group and World:
  - -rw-rwr-- 1 coop aproject 1601 Mar 9 15:04 a_file

File Access Rights:
  - specialized permissions -- setuid & setgid

File Permission and Security and Authentication:
  - Order of authentication:
    -- if the requester is the owner, the file owner permission are used
    -- otherwise, if the requester is in the group that owns the files, the group permissions are examined
    -- if that doesn't succeed, the world permissions are examined.

Changing Permissions: chmod:
  - chmod uo+x,g-w a_file

chmode: Numerical Syntax fro Permissions:
  - octal form --> 0755
  - symbolic form --> u+rwx,g+rwx,o+rx
  - 4 - read, w - write, x - execute

Changing User and Group File Ownership: chown and chgrp:
  - chown coop:aproject a_file

umask:
  - default permissions for:
    -- file --> 0666
    -- folder --> 0777
  - using 'umask':
    - for file of 0666 --> 0666 & ~002 = 0664; folder --> 0777 & ~002 = 0775;
  - change 'umask':
    - $ umask 0022

Filesystem ACLs:
  - Access Control Lists:
    - with this its possible to grant specific users or groups particular privileges without using 777 permissions
    - default set of ACLs is created at system install.

Getting and Setting ACLs:
  - To see ACLs:
    - getfacl file|directory
  - To set ACLs:
    - setfacl options permissions file|directory
    - $ setfacl -m u:isablella:rx /home/george/file2
    - $ setfacl -x u:isabella /home/george/file
    Note: 'mv' and 'cp -p' preserve ACLs
  - To remove ACLs:
    - setfacl -x u:isabella /home/george/file1
  - To set the default on directory:
    - $ setfacl -m d:u:isabella:rx somedir

<------------------------------------------File Permissions and Ownership ------------------------------------------->
                                                Chapter 35

DAC - directory access control

Learning Objectives:
 - explain the concepts of owner, group, and world
 - set file access rights (read, write, and execute) for each category
 - authenticate requests for file access, respecting proper permissions
 - use chmod to change file permissions, chown to change user ownership, and chgrp to change group ownership
 - understand the role of umask in stablishing desired permission on newly created files.
 - user ACLs to extend the simpler user, group, world and read, write, execute model.

Owner, Group and World:
 - -rw-rwr-- 1 coop aproject 1601 Mar 9 15:04 a_file

File Access Rights:
 - specialized permissions -- setuid & setgid

File Permission and Security and Authentication:
 - Order of authentication:
   -- if the requester is the owner, the file owner permission are used
   -- otherwise, if the requester is in the group that owns the files, the group permissions are examined
   -- if that doesn't succeed, the world permissions are examined.

Changing Permissions: chmod:
 - chmod uo+x,g-w a_file

chmode: Numerical Syntax fro Permissions:
 - octal form --> 0755
 - symbolic form --> u+rwx,g+rwx,o+rx
 - 4 - read, w - write, x - execute

Changing User and Group File Ownership: chown and chgrp:
 - chown coop:aproject a_file

umask:
 - default permissions for:
   -- file --> 0666
   -- folder --> 0777
 - using 'umask':
   - for file of 0666 --> 0666 & ~002 = 0664; folder --> 0777 & ~002 = 0775;
 - change 'umask':
   - $ umask 0022

Filesystem ACLs:
 - Access Control Lists:
   - with this its possible to grant specific users or groups particular privileges without using 777 permissions
   - default set of ACLs is created at system install.

Getting and Setting ACLs:
 - To see ACLs:
   - getfacl file|directory
 - To set ACLs:
   - setfacl options permissions file|directory
   - $ setfacl -m u:isablella:rx /home/george/file2
   - $ setfacl -x u:isabella /home/george/file
   Note: 'mv' and 'cp -p' preserve ACLs
 - To remove ACLs:
   - setfacl -x u:isabella /home/george/file1
 - To set the default on directory:
   - $ setfacl -m d:u:isabella:rx somedir

<----------------------------------- File Permissions and Ownership ------------------------------------------->
                                    Chapter 35

DAC - directory access control

Learning Objectives:
  - explain the concepts of owner, group, and world
  - set file access rights (read, write, and execute) for each category
  - authenticate requests for file access, respecting proper permissions
  - use chmod to change file permissions, chown to change user ownership, and chgrp to change group ownership
  - understand the role of umask in stablishing desired permission on newly created files.
  - user ACLs to extend the simpler user, group, world and read, write, execute model.

Owner, Group and World:
  - -rw-rwr-- 1 coop aproject 1601 Mar 9 15:04 a_file

File Access Rights:
  - specialized permissions -- setuid & setgid

File Permission and Security and Authentication:
  - Order of authentication:
    -- if the requester is the owner, the file owner permission are used
    -- otherwise, if the requester is in the group that owns the files, the group permissions are examined
    -- if that doesn't succeed, the world permissions are examined.

Changing Permissions: chmod:
  - chmod uo+x,g-w a_file

chmode: Numerical Syntax fro Permissions:
  - octal form --> 0755
  - symbolic form --> u+rwx,g+rwx,o+rx
  - 4 - read, w - write, x - execute

Changing User and Group File Ownership: chown and chgrp:
  - chown coop:aproject a_file

umask:
  - default permissions for:
    -- file --> 0666
    -- folder --> 0777
  - using 'umask':
    - for file of 0666 --> 0666 & ~002 = 0664; folder --> 0777 & ~002 = 0775;
  - change 'umask':
    - $ umask 0022

Filesystem ACLs:
  - Access Control Lists:
    - with this its possible to grant specific users or groups particular privileges without using 777 permissions
    - default set of ACLs is created at system install.

Getting and Setting ACLs:
  - To see ACLs:
    - getfacl file|directory
  - To set ACLs:
    - setfacl options permissions file|directory
    - $ setfacl -m u:isablella:rx /home/george/file2
    - $ setfacl -x u:isabella /home/george/file
    Note: 'mv' and 'cp -p' preserve ACLs
  - To remove ACLs:
    - setfacl -x u:isabella /home/george/file1
  - To set the default on directory:
    - $ setfacl -m d:u:isabella:rx somedir

<---------------------------------------------------- Pluggable Authentication Modules (PAM) ----------------------------------------------->
                                                              Chapter 36
Note: PAM can work with LDAP (Lightweight Directory Access Protocol) to provide centralized authentication throughout a network

Learning objectives:
  - explain the basic concepts that motivate the use of PAM
  - list the steps involved in the authentication process
  - use and modify PAM configuration files.
  - know how to interpret PAM rules and create new ones.
  - apply LDAP to use and administer distributed directory services over the network

PAM: A Unified Approach to Authentication:
  - uses libpam
  - PAM incorporates the following components:
    - PAM-aware applications
    - Configuration files in /etc/pam.d
    - PAM modules in the libpam* libraries, which can be found in different locations depending on Linux distribution.
  - Each PAM-aware application, or service, may be configures with respect to PAM by an individual configuration file in /etc/pam.d

Athentication Process:
  - The steps include:
    - user invokes PAM-aware application, such as login, ssh, or su
    - the application calls libpam
    - the library checks for files in /etc/pam.d; these delineates which PAM modules to invoke, including system-auth.
    - each referenced module is executed in accordance with the rules of relevant configuration file for that apllication

PAM Configuration Files:
  - rules in the pam.d config files:
    - type control module-path module-arguments

PAM Rules:
  - type:
    - auth -- tells application to prompt for user identification
    - account -- checks aspect of user account such as password aging, access control
    - password -- updating user authentication token
    - session -- used to provide functions before and after the session is established ( setting up environmental variables)
  - Control:
    - required: must return success for service to be granted, if part of a stack all other modules will run and the application would not be told which module failed
    - requisite: same as required but any failure terminates the stack and return status is sent
    - optional: modules is not required, if only module then then its return status to application may cause failure.
    - sufficient: if this module succeeds then no subsequent modules in stack are executed.
  - Other control flags include:
    - substack
  - module-path:
    - file name of the library to be found in /lib*/security either absolute or relative path form
  - module-arguments:
    - can be given to modify the PAM module's behaviour

LDAP:
  - structure:
    -- client----->LDAP Server
                       / \
                        |
                        V
                TLS (Transport Layer Security)
  - When a system is configured for LDAP authentication, five files are changed:
    - /etc/openldap
    - /etc/pam_ldap.conf
    - /etc/nslcd.conf
    - /etc/sssd/sssd.conf
    - /etc/nsswitch.conf
    - these files can be edited manually or using tools like system-config-authentication or authconfiglg-tul.

<----------------------------------------------------- Backup and Recovery Methods -------------------------------------------->

                                                             Chapter 37

Learning objectives:
  - identify and prioritize data that needs backup
  - employ different kinds of backup methods, depending on the situation
  - establish efficient backup and restore strategies
  - use different backup utilities, such as 'cpio, tar, gzip, bzip2, xz, dd, rsync, dump, restore and mt'
  - describe the two most well-known backup programs, Amanda and Bacula.

Why Backup ?
  - data is valuable
  - hardware fails
  - software fails
  - people make mistakes
  - malicious people can cause deliberate damage
  - unexplained events happen
  - rewinds can be useful

What Needs Backup ?
  - 1. Definitely:
        - business-realted data
        - system configuration files
        - User files (usually under /home)
    2. Maybe:
        - spooling directories ( for printing mail etc )
        - Logging files ( found in /var/log, and elsewhere )
    3. Probably not:
        - installed software
        - the /tmp directory
    4. Definately not:
        - psuedo-filessystems such as /proc, /dev and /sys
        - any swap partitions or files

Tape Drives:
  - LTO (Linear Tape Open) variety
  - 100GB to 2.5TB version

Backup Methods:
  - Full:
    - a full backup
  - Incremental:
    - backup only changed files that have changed since last full backup or incremental bsckup
  - Differential:
    - backup all changed files since last full backup
  - Multiple level Incremental:
    - files that have changed since the previous backup at the same or previous lvel
  - User:
    - only specific files in user's directory are backed up

Backup Strategies:
  - helps to ensure proper backup is done right

Backup Utilities:
  - cpio
  - tar
  - gzip, bzip2, xz:
    - cpio and tar create and extract archives of files.
    - useful for transferring files from one filesystem or machine to another
  - dd:
    - transfer raw data btween media.
    - can copy entire partitions or entire disks
  - rsync:
    - can synchronize directory subtrees or entire filesystems across a network, or bwteen filesystem locations on a local machine
  - dump and reestore:
    - read filesystems directly but must be restored on only same filesystem type they came from.
  - mt:
    - useful for querying and positioning tapes before performing backups and restores.

cpio:
  - lighter than 'tar'
  - used by Linux kernel
  - use:
    - ls | cpio --create -O /dev/st0 -> create an archive [use: -o or --create]
    - cpio -i somefile -I /dev/st0 -> extract from an archive [use: -i or --extract]
    - cpio -t -I /dev/st0 -> list contents of an archive [ use: -t -r --list]

tar:
  - easier than 'cpio'
  - reconsitutes directories as needed
  - does incremental backups with '--newer' option
  - handles backups not on one device
  - use:
    - create:
      - tar --create --file /dev/st0 /root
      - tar -cvf /dev/st0 /root, or using -f or --file options
    - create with multi volume with -M or --multi-volume
      - tar -cMf /dev/sto /root, will be prompted for next tape
    - verify:
      - tar --compare --verbose --file /dev/st0
      - tar -dvf /dev/st0

Using tar for Backups (cont.):
  - short options -c, long options --create
  - same command: tar cvf file.tar dir1 === tar -cvf file.tar dir1

Using tar for Restoring Files:
  - options include:
    - -x or --extract
    - -p or --same-permissions --> keeps file permissions
    - -t or --list --> don't extract just list
    - uses:
      - extract:
        - tar --extract --same-permission --verbose --file /dev/st0
        - tar -xpvf /dev/st0
        - tar xpvf /dev/st0
      - specifying of specific files to restore:
        - tar xvf /dev/st0 somefile
      - listing contents of a tar backup:
        - tar --list --file /dev/st0
        - tar -tf /dev/st0

Incremetal Backups with tar:
  - using -N or --newer
  - tar --create --newer '2011-12-1' -vf backup1.tar /var/tmp
  - tar --create --after-data '2011-12-1' -vzf backup1.tar /var/tmp


Compression: gzip, bzip2 and xz and Backups:
  - based on compression efficiency:
    - gzip: uses Lempel-Ziv Coding (LZ77), produces .gz files
    - bzip2: uses Burrows-Wheeler block sorting text compression algorithm and huffman coding, and produces .bz2 files
    - xz: produces .xz files and also supports legacy .lzma format
    - .zip format is rarely used in Linux except legacy archives from other operating systems.
    - using compression utilities with tar:
      - tar zcvf source.tar.gz source
      - tar jcvf source.tar.bz2 source
      - tar Jcvf source.tar.xz source
      - for the first command we could also do:
        - tar cvf source.tar source ; gzip -v source.tar
    - decompression:
      - tar xzvf source.tar.gz
      - tar xjvf source.tar.bz2
      - tar xJvf source.tar.xz
      - simpler version:
        - tar xvf source.tar.gz
        - Note: don't use on already compressed files such as: .jpg, .pdf
      - Note meaning of options:
        - tar 1234 name_of_compressed_file_with_appropraite_extension file_to_compress
                                    --> 1 => type of compression
                                    --> 2 => compress command
                                    --> 3 => verboseness
                                    --> 4 => file to compress
        - tar 1234 file_to_decompress
                                    --> 1 => decompress command
                                    --> 2 => type of decompression
                                    --> 3 => verboseness
                                    --> 4 => file to decompress

dd:
  - use:
    - dd if=input-file of=output-file options

dd Examples:
  - create 10MB file filled with zeros:
    - dd if=/dev/zero of=outfile bs=1M count=10
  - backup an entire hard drive to another (raw copy):
    - dd if=/dev/sda of=/dev/sdb
  - create an image of a hard disk (which could be transferred to another hard disk):
    - dd if=/dev/sda of=sdadisk.img
  - backup a partition:
    - dd if=/dev/sda1 of=/partition1.img
  - Use dd in a pipeline:
    - dd if=ndata conv=swab count=1024 | uniq > ofile

rsync:
  - remote synchronize
  - used to transfer files across a network or between different locations on the same machine:
    - rsync [options] source destination
    - rsync file.tar someone@backup.mydomain:/usr/local
    - rsync -r a-machine:/usr/local b-machine:/user/
    - rsync -t --dry-run /usr/local /BACKUP/usr
    - good use for backup would be:
      - rsync -r project-X archive-machine:archives/project-X

dump and restore:
  - directly reads and writes the filesystem amking it more efficient
  - Features include:
    - incremental backups
    - understand specific filesystems and how to read it
    - efficient when creating full back-ups
    - can specify output tape size, density, block size and count, or even both
    - dump to any valid device or file: defaults to /dev/tape
    - parameters in /etc/fstab control what gets dumped and when

  - Negative features:
    - multiple filesystem passes are required for backups
    - only works for ext2, ext3, and ext4 filesystems
    - can't be run efficiently on mounted filesystems

dump Options:
  - -0-9:
    - Level 0 is a full backup and higher numbers are incremental backups
  - -B records:
    - records per volume
  - -b blocksize:
    - KB per record
  - -f file:
    - output device or file
  - -u:
    - update /etc/dumpdates/
  - -W:
    - print most recent dump date of each filesystem in /etc/dumpdates or /var/lib/dumpdates (for debian systems)

Level 0 Backup with dump:
  - sudo dump -0uf /tmp/boot_backup /boot_master


restore:
  - used to restore files that where created using 'dump'
  - sudo restore -rvf /tmp/boot_backup
  - Options:
    - -r restore everything
    - -t list on standard out with no restoration
    - -x files and directory are extracted
    - -i interactive restoration

mt:
  - used to control magnetic tape devices
  - options:
    - -h help
    - -f device: specify tape device
    - operation
    - count: used for repeat operations
    - arguments: used for some operations
    - mt [-h] [-f device] operation [count] [arguments...]
    - use:
      - mt status
      - mt rewind
      - mt erase
      - mt fsf --> move forward to the end of the current device.

<------------------------------------------------------ Network Addresses -------------------------------------------------->

                                                        Chapter 38

Addresses come in different classes according to the size of the local networks and it is important to be able to recognize the class based
on the address value

Learning Objectives:
  - differentiate between different types of IPv4 and IPv6 addresses
  - get, set, and change the hostname, based on the system you are using.

IP Address:
  - used globally and uniquely to identify nodes across the internet
  - registered through ISPs
  - two varieties include:
    - IPv4 : 32-bit address, composed of 4 octets e.g. 148.114.252.10
    - IPv6 : 128-bit address, composed of 8 octets, e.g. 2003:0db5:6123:0000:1f4f:0000:5529:fe23

IPv4 Address Types:
  - Unicast:
    - address associated with a specific host: 140.211.169.4 or 64.254.248.193
  - Network:
    - address whose host portion is set to all binary zeroes, e.g. 192.168.1.0 the host portion can be 1-3 octets
  - Broadcast:
    - address to which each member of a particular network will listen. Will have the host portion set to all 1 bits, such as in 172.16.255.255,
    148.114.255.255, and 192.168.1.255
  - Multicast:
    - address to which appropraitely configured nodes will listen. The address 224.0.0.2 is an example of a multicast address.
      Only nodes specifically configured to pay attention to a specific multicast address will interpret packets for that multicast group.

Special Addresses:
  - certain addresses and address ranges are reserved for special purposes:
    - 127.x.x.x where 0 <= x <= 254
    - 0.0.0.0:
      - used by systems that do not yet know their own address. e.g DHCP and BOOTP use this when attempting to communicate with a server
    - 255.255.255.255
      - generic broadcast private address, reserved for internal use. Never assigned to any group
    - Other examples of reserved address ranges include:
      - 10.0.0.0 - 10.255.255.255
      - 172.16.0.0 - 172.31.255.255
      - 192.168.0.0 - 192.168.255.255, etc

IPv6 Address Types:
  - Unicast:
    - A packet is delivered to one interface:
      - Link-local:
      - Global
      - Reserved for documentation
    - Multicast:
      - A packet is delivered to multiple interface
    - Anycast:
      - A packet is delivered to the nearest of multiple interfaces (in terms of routing distance)
    - IPv4-mapped:
      - An IPv4 address mapped to IPv6. For example, ::FFFF:a.b.c.d/96
      - loopback use IPv6

IPv4 Address Classes:
   - IP Addresses are based on defined classes, A, B, and C are used to distinguish a network portion of the address from
   a host portion of the address.

   Network Class        |     Highest order octet range   |  Notes
   ----------------------------------------------------------------------------------------------------------------
   A                    |1-127                            | 128 networks, 16,772,214 hosts per network, 127.x.x.x reserved for loopback
   B                    |128-191                          | 16,384 networks, 65,534 hosts per network
   C                    |192-223                          | 2,097,152 networks, 254 hosts per network
   D                    |224-239                          | Multicast addresses
   E                    |240-254                          | Reserved address range
   ===============================================================================================================

Netmasks:
  - used to determine how much of the address is used for network portion and how much for thr host portion
  as we have seen. It is also used to determine network and broadcast addresses.



  Network Class      | Decimal                  | Hex                       |  Binaries
  -------------------------------------------------------------------------------------------------------------------
  A                  |255.0.0.0                 | ff:00:00:00               | 11111111 00000000 00000000 00000000
  B                  |255.255.0.0               | ff:ff:00:00               | 11111111 11111111 00000000 00000000
  C                  |255.255.255.0             | ff:ff:ff:00               | 11111111 11111111 11111111 00000000
  ===================================================================================================================

  Class A addresses use 8 bits for the network portion of the address and 24 bits for the host portion of the address
  Class B addresses use 16 bits for the network and 16 bits for the host
  Class C addresses use 24 bits for the network and 8 for the host.
  Class D addresses are used for multicasting.
  Class E addresses are currently not used.

  Obtaining network addresses:
    - IP address & netmask --> 172.16.2.17 &255.255.0.0 --> 172.16.0.0

Hostname:
  - label used to distinguish a network device from other elements on the network. Also called a nodename
  - For DNS purposes, hostnames are appended with a period (dot) and a domain name:
    - thus antje --> FQDN ==> antje.linuxfoundation.org

Getting and Setting the Hostname:
  - to get the hostname `$ hostname`
  - changing the hostname:
    - $ sudo hostname lumpy (not persisted)
  - location of hostname in:
    - Ubuntu /etc/hostname
    - SUSE /etc/HOSTAME
    - RHEL /etc/sysconfig/network
  - to persist use `hostnamectl`
    - sudo hostnamectl set-hostname MYPC

<--------------------------------------------------------- Network Devices and Configuration ----------------------------------------------->
                                                                      Chapter 39
Learning Objectives:
  - be able to identify network devices and understand how thr OS names them and binds them to specific duties
  - use the lp utility to display and control devices, routing, policy-based routing, and tunneling
  - use ifconfig to configure, control, and query network interface parameters from either the command line or from system system configuration scriptd
  - use Network Manager (nmtul and nmcli) to configure network interfaces in a distribution-independent manner
  - know how to set default routes and static routes
  - configue name resolution as well as run diagnostic utilities.

Network Devices:
  - network devices are not associated with special device files, also devices nodes
  - rather than having associated entries in the /dev directory, they are known by their names.
  which consist of a type identifier followed by a number as in:
    - eth0, eth1, eno1, eno2 etc. For ethernet devices
    - wlan0, wlan1, wlan2, wlp3s0, wlp3s2, etc. For wireless devices
    - br0, br1, br2 etc. For bridged interfaces
    - vmnet0, vmnet1. vmnet2 etc. For virtual devices for communicating with virtual clients

  - Sometimes multiple virtual devices can be associated withsingle physical devices.

Problems with Network Device Names:
  - these includes:
    - distinguishing between interfaces of the same type and their connection to physical devices on the system.
    - dynamic nature of MAC address

Predictable Network Interface Device Names:
  - PNIDN:
    - strongly correlated with the use of 'udev' and integration with 'systemd'.
    - 5 types of names that devices can be given:
      - incorporating firmware or BIOS provided index numbers for on-board devices:
        > eno1
      - incorporating firmware or BIOS provided PCI Express hotplug slot index numbers:
        > ens1
      - incorporating Physical and/or geographic location of the hardware connection:
        > enp2s0
      - incorporating the MAC address:
        > enx7837d1ea46da
      - using the old classic method:
        - eth0

Examples of the New Naming Scheme:
  - commands:
    - ip, ifconfig | grep enp, ifconfig grep wl, lspci | grep <device name>

ip:
  - preferred to 'ifconfig' since its more versatile and more proficient
  since it uses the 'netlink' sockets rather than ioctl system calls.
  - can be used for:
    - configuration
    - control and query devices and interface devices
    - manipulate routing, policy based routing, and tunneling.
    - syntax:
      - ip [ OPTIONS ] OBJECT { COMMAND | help }
      - ip [ -force ] -batch filename, this can read commands from a disgnated file
    - it is a multiplex utility; the OBJECT argumant describe what kind of action is going to be
    performed.
      - Main ip OBJETS:
        OBJECT          | FUNCTION
        -----------------------------------------------------------------------------------------------
        address         | IPv4 or IPv6 protocol device address
        link            | Network Devices
        maddress        | Multicast Address
        monitor         | Watch for netlink messages
        route           | Routing table entry
        rule            | Rule in the routing policy database
        tunnel          | Tunnel over IP

Examples of Using ip:
  - show information for all network interfaces:
    - $ ip link
  - show info for the eth0 network interface:
    - $ ip -s link show eth0
  - set the IP address for eth0:
    - sudo ip addr add 192.168.1.7 dev eth0
  - bring eth0 down:
    - sudo ip link set eth0 down
  - set the MTU to 1480 bytes for eth0:
    - sudo ip link set eth0 mtu 1480
  - set the networking route:
    - sudo ip route add 172.16.1.0/24 via 192.168.1.5

ifconfig:
  - used to:
    -  configure, control, and query network interface parameters from either command line or from system configuration scripts
    - it has been superseded by 'ip' and some Linux dsitribution no longer install it by default.
    - commands include:
      - display info about all interfaces:
        - ifconfig
      - display info about only eth0:
        - inconfig eth0
      - set the IP address to 192.168.1.50 on interface eth0:
        - sudo ifconfig eth0 192.168.1.50
      - set netmask to 24-bit
        - sudo ifconfig eth0 netmask 255.255.255.0
      - bring interface eth0 down:
        - sudo ifconfig eth0 down
      - set the MTU (Maximum Transfer Unit) to 1480 bytes for interface eth0:
        - sudo ifconfig etho mtu 1480

NIC Configuration Files:
  - network interface configurations location: /etc/network/interfaces
  - use network manager to persist changes to network interface

Network Manager:
  - preferred means to configure a network

Network Manager Interfaces:
  - Means of configuring a network interface:
    - GUI:
    - ntmui:
      - no learning curve and edits underlying
    - nmcli:
      - use this to run scripts

nmtui:
  -

nmcli:
  - man nmcli-examples
  - nmcli --help
  - usage: nmcli [OPTIONS] OBJECT { COMMAND | help }

Routing:
  - this is the process of selecting paths in a network along which to send network traffic.
  - Route table:
    - a list of routes to other networks managed by the system.
    - it defines paths to all networks and hosts, sending remote traffic to routers
    - to see the current routing table:
      - /sbin/route or ip route

Default Route:
  - this is the way packets are sent when there is no other match in the routing table
  for reaching the specified network
  - it can be obtained dynamically using DHCP. However, it can also be mutually configured(static).
  With nmcli it can be done via:
    - sudo nmcli con mod virbr0 ipv4.routes 192.168.10.0/24 +ipv4.gateway 192.168.122.0
    - sudo nmcli con up virbr0

Static Routes:
  - are used to control packet flow when there is more than one router or route.
  - are defined for each interface and can be either persistent or non-persistent
  - either the route or ip command can be used to set a non-persistent route as in:
    - sudo ip route add 10.5.0.0/16 via 192.168.1.100
    - route
    - persistent route can be set:
      - on RHEL: /etc/sysconfig/network-scripts/route-ethX
      - on Debian: /etc/network/interfaces
        - iface eth1 inet dhcp
            post-up route add -host 10.1.2.51 eth1
            post-up route add -host 10.1.2.52 eth1
      - on SUSE: /etc/sysconfig/network/ifroute-eth0

Name Resolution:
  - is the act of translating hostnames to the IP addresses of their hosts.
  - e.g. - linux.org --> resolution --> 123.234.223.3 --> make requests to linux.org
  - There are two facilities for doing this translation:
    - Static name resolution (using /etc/hosts)
    - Dynamic name resolution (using DNS servers)
  - From command line:
    - [dig | host | nslookup] linuxfoundation.org
      - dig: generates the most information and has many options
      - host: more compact
      - nslookup: older
  - Note: may also require 'reverse resolution': converting an IP address to a host name.

/etc/hosts:
  - holds a local database of hostnames and IP addresses.
  - it is checked first before DNS is attemped to resolve an address; however, this priority can be controlled
  by /etc/nsswitch.conf

DNS:
  - when a name resolution can not be done locally using /etc/hosts, then the system will query a DNS (Domain Name Server) server.
  - it consist of a network of servers which a client uses to look up names. The service is distributed; any one DNS server has only information about its 'zone of authority'
  - the machine's usage of DNS is configures in /etc/resolv.conf, which
   - can specify particular domains to search
   - defines a strict order of nameservers to query
   - may be manually configured or updated from a service such as DHCP
  - most modern systems will have a /etc/hosts.resolv file generated automatically

Network Diagnostic Utilities:
  - ping:
    -
  - traceroute:
    - used to display a network path to a destination.
  - mtr:
   - combines functionality of 'ping' and 'traceroute'
  - dig:
   - useful for testing DNS functionality

<------------------------------------------------------------------------- Firewalls ------------------------------------------------->

                                                                    Chapter 40
Objective:
  - understand what firewalls are and why they are necessary
  - know both the comman line and GUI tools used
  - be familiar with 'firewalld' and the 'firewall-cmd' program
  - know how to work with zones, sources, services and ports.

What is a Firewall:
  - may be hardware or software based
  - found in:
   - network routers
   - individual computers
   - network nodes
  - many have routing capabilities
  - the three types of firewalls are:
    - packet filtering firewalls -- content were inspected
    - stateful filters -- content were inspected and the state of the connection checked
    - application layer firewalls --
     -- checked: type of application and protocol being used
     -- block anygthing that should not be part of the normal flow

Firewall Interface and Tools:
  - using low level tools from the command line, combined withediting various configuration files in /etc folder
    -- iptables
    -- firewall-cmd
    -- ufw
  - using robust graphical interfaces:
   -- system-config-firewall
   -- firewall-config
   -- gufw
   -- yast


firewalld:
  - Dynamic Firewall Manager:
    - utilizes network/firewall 'zones' which have defined levels of trust for network interfaces or connections.
    - it supports both ipv4 and ipv6 protocols
    - it separates 'runtime' and 'permanent' changes to configuration, and also includes interfaces for
    services or applications to add firewall rules
    - config files are kept in:
      - /etc/firewalld and /usr/lib/firewalld; those in /etc/firewalls override the latter
      - the command 'firewall-cmd' controls the 'firewall'
    NOTE: firewalld replaces 'iptable' and its an 'error' to use both at the same time

firewall Service Status:
  - sudo systemctl [enable/disable] firewalld
  - sudo systemctl [start/stop] firewalld
  - sudo systemctl status firewalld
  - sudo firewall-cmd --state --> checking the state
  - when runnig more than one network interface using ipv4, you have to turn on ip forwarding.
    - sudo sysctl net.ipv4.ip_forward=1
    - echo 1 > /proc/sys/net/ipv4/ip_forward (needs to be run as root to get echo to work)
    - to persist the changes add to /etc/sysctl.conf the line:
      - net.ipv4.ip_forward=1
      - sudo sysctl -p ( to read in the new setting without rebooting)

Zones:
  - each zone is a defined level of trust and a certain known behaviour for incoming and outgoing packets.
  - each interface belongs to a particular zone (normally it is NetworkManager which informs firewalld which zone is applicable)
  - The zones:
    - drop -- block all incoming with no reply, outgoing connections are permitted
    - block -- all incoming rejected. Only those within the system accepted
    - public -- all computers on network not trusted, only certain conciuosly selected incoming connections are permitted
    - external -- used when nasquerading is being used, such as in routers. Trust levels the same as in public
    - dmz -- (demilitarized Zone) used when access to some (but not all) services are to be allowed to the public.
      only incoming connections are allowed.
    - work -- trust (but not completely) connected nodes to be not harmful. Only certain incoming connections are allowed
    - home -- mostly trsut the other network nodes, but still select which incoming connection are allowed
    - internal -- similar to the work zone
    - trusted-- all networks connections are allowed.

Zone Management:
  - Get default zone:
    - sudo firewall-cmd --get-default-zone
  - obtain a list of zones currently being used:
    - sudo firewall-cmd --get-zone
  - to change the default zone to trusted and then the change it back
    - sudo firewall-cmd --set-default-zone=trusted
    - sudo firewall-cmd --set-default=public
  - to assign an interface temporarily to a particular time zone
    - sudo firewall-cmd --zone=internal --change-interface=eno1
    - permanently -- sudo firewall-cmd --permanent --zone=internal --change-interface=eno1
  - to acertain the zone associated with a particular interface
    - sudo firewall-cmd --get-zone-of-interface=eno1
  - to get details about a particualr zone:
    - sudo firewall-cmd --zone=public --list-all

Source Management:
  - zones can be bound not just to a network interface, but also to particular addresses.
  - Packets are associated with a zone if:
    - it comes from a source address already bound to the zone; or if not,
    - it aomes from an interface bound to the zone
    - any packet not fitting the above is assigned to the default zone
  - to assign a source permanently:
    - sudo firewall-cmd --permanent --zone=trusted --add-source=192.168.1.0/24
    - remove source with --remove-source, or change source with --change-source
  - list sources bound to a zone:
    - sudo firewall-cmd --permanent --zone=trusted --list-sources

Service and Port Management:
  - To see what services are available within assigned zones:
    - sudo firewall-cmd --get-services
  - to see currently accessible sevices within a zone:
    - sudo firewall-cmd --list-services --zone=public
  - to add service to a zone:
    - sudo firewall-cmd --permanent --zone=home --add-service=dhcp
    - sudo firewall-cmd --reload
    - can also add service here /etc/firewall/services
  - add ports to zones
    - sudo firewall-cmd --zone=home --add-port-21/tcp
  - list ports:
    - sudo firewall-cmd --zone=home --list=ports
    - whereby looking at /etc/services we can ascertain configured ports
      - grep " 21/tcp" /etc/services

<--------------------------------------------------- Basic Troubleshooting ----------------------------------------------------->
                                                          Chapter 41

Learning objectives:
  - following a number of steps iteratively until solutions are found.
  - check your network and file integrity for possible issues.
  - resolve problems when there is system boot failure.
  - repair and recover corrupted filesystems
  - understand how rescue and recovery media can be used for troubleshooting

Troubleshooting Overview:
  - Three levels of troubleshooting include:
    - beginner
    - experienced
    - wizard

Basic Techniques:
  - These include:
    - xterize the problem
    - reproduce the problem
    - always try the easy steps first
    - eliminate possible cuases one at a time
    - change one thing at a time; if that doesn't fix the problem, change it back.
    - check the system logs (/var/log/messages, /var/log/secure, etc) fir further information


Intuition and Experience:
  - good intuition is built from experience
  - good procedures help lessen dependence on any one individual

Things to Check: Networking -
  - IP configuration:
    - use ifconfig or ip; to check if"
      -- the interface is up and if up if configured well
    - Network Driver:
      - is the correct driver loaded.
      - check with 'lsmod'
      - or check relevant pseudo-files:
        -- /proc/interrupts, /sys/class/net
    - Connectivity:
      - use ping to see if network is visible
      - traceroute can follow packets through the network
      - mtr: can do this in a continues fashion.
    - Default gateway and routing configuration:
      - run route -n and see if the routing table make sense.
    - Hostname resoulution:
      - run dig or host on a URL and see if DNS is working

Things to Check: File Integrrity -
  - For RPM-based systems:
    - rpm -V some_package
    - rpm -Va --> checks all package on the system
  - On Debian-based systems
    - debsum options some_package
    - dkpg [-V | --verify] package_name
  - aides and --check
    - does intrusion checks on your files comparing them to the last scan.

Boot Process Failures:
  - If BIOS state is passed:
    - No bootloader screen:
      -- check for GRUB misconfiguration, or a corrupt boot sector. You may have to re-install the bootloader
    - Kernel fails to load:
      - if kernel panics during the boot process. It is most likely a misconfiguration or corrupt kernel
      or incorrect parameters specified on the kernel command line in the GRUB configuration file has been altered.
    - Kernel loads but fails to mount the boot filesystem:
      The main causes here are:
        - 1. Misconfigured GRUB configuration fiel
        - 2. Misconfigured /etc/fstab
        - 3. no support for the root file system type either built into the kernel or as a module in the initramfs Initial ram
        disk or filesystem
    - Failure during the 'init' process.
      - repair may invovle booting into a lower runlevel such as 3 (no graphics) or 1 (single mode)

Filesystem Corruption and Recovery:
  - To repair check '/etc/fstab':
    - sudo mount -o remount,rw /
    - if '/etc/fstab' seems to be correct:
      - sudo mount -a, then
      - run: fsck and mount particular file systems that are faulty.

Using Rescue/Recovery Media:
  - Categories of tools:
    - Disk Maintenance Utilities
    - Netwworking Utilities
    - Miscellaneous Utilities
    - Logging files

Common Utilities on Rescue/Recovery Media:
  - Disk utilities for creating partitions, managing RAID devices, managing logical volume, and creating filesystems
    - fdisk, mdadm, pvcreate, vgcreate, lvcreate, mkfs, etc
  - Networking utilities for network debugging and network connectivity:
    - ifconfig, route, traceroute, mtr, host, ftp, scp, ssh
  - Numerous other commands are also available:
    - bash, chroot, ps, kill, vi, dd, tar, cpio, gzip, rpm, mkdir, ls, cp, mv, and rm etc

Using Rescue/Recovery Media:
  - FIlesystem to be rescured are usually mount at /mnt/sysimage
  - you can move or change into that environment with:
    - sudo chroot /mnt/sysimage
    - for networl rescue you may need to mount /mnt/source


<------------------------------------------------------- System Rescue ----------------------------------------------------------->
                                                          Chapter 42
Learning objectives:
  - explin what forms system rescue media come in and how they are amde available or can be prepared
  - know how to enter emergency mode and what can be done there
  - know how to enter single user mode, what can be done there, and how it differs from emergency mode


Emergency Boot Media:
  - needed when:
    - misconfigured, missing files or service exist
    - root possword recovery
    - runs in memory
